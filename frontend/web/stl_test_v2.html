<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Test - Single Part Visualization</title>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif; 
            background: #1a1a1a; 
            color: white; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 80vh; 
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 100%);
        }
        #controls {
            padding: 20px;
            background: #2a2a2a;
            text-align: center;
        }
        button {
            margin: 0 10px;
            padding: 10px 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #2563eb;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            background: #374151;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="controls">
        <h2>STL Single Part Test</h2>
        <div id="status">Initializing...</div>
        
        <button onclick="loadSTL('Base_SO101.stl')">Load Base</button>
        <button onclick="loadSTL('Upper_arm_SO101.stl')">Load Upper Arm</button>
        <button onclick="loadSTL('sts3215_03a_v1.stl')">Load Motor</button>
        <button onclick="loadSTL('Moving_Jaw_SO101.stl')">Load Gripper</button>
        <button onclick="clearScene()">Clear</button>
    </div>

    <script>
        // STLLoader class (inlined to avoid CDN issues)
        class STLLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(scope.manager);
                loader.setPath(scope.path);
                loader.setResponseType('arraybuffer');
                loader.setRequestHeader(scope.requestHeader);
                loader.setWithCredentials(scope.withCredentials);
                loader.load(url, function (text) {
                    try {
                        onLoad(scope.parse(text));
                    } catch (e) {
                        if (onError) {
                            onError(e);
                        } else {
                            console.error(e);
                        }
                        scope.manager.itemError(url);
                    }
                }, onProgress, onError);
            }

            parse(data) {
                function isBinary(data) {
                    const reader = new DataView(data);
                    const face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);
                    const n_faces = reader.getUint32(80, true);
                    const expect = 80 + (32 / 8) + (n_faces * face_size);
                    if (expect === reader.byteLength) {
                        return true;
                    }
                    const fileLength = reader.byteLength;
                    for (let index = 0; index < fileLength; index++) {
                        if (reader.getUint8(index, false) > 127) {
                            return true;
                        }
                    }
                    return false;
                }

                function parseBinary(data) {
                    const reader = new DataView(data);
                    const faces = reader.getUint32(80, true);
                    let r, g, b, hasColors = false, colors;
                    let defaultR, defaultG, defaultB, alpha;

                    for (let index = 0; index < 80 - 10; index++) {
                        if ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&
                            (reader.getUint8(index + 4) == 0x52 /*'R'*/) &&
                            (reader.getUint8(index + 5) == 0x3D /*'='*/)) {
                            hasColors = true;
                            colors = [];
                            defaultR = reader.getUint8(index + 6) / 255;
                            defaultG = reader.getUint8(index + 7) / 255;
                            defaultB = reader.getUint8(index + 8) / 255;
                            alpha = reader.getUint8(index + 9) / 255;
                        }
                    }

                    const dataOffset = 84;
                    const faceLength = 12 * 4 + 2;
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const normals = [];

                    for (let face = 0; face < faces; face++) {
                        const start = dataOffset + face * faceLength;
                        const normalX = reader.getFloat32(start, true);
                        const normalY = reader.getFloat32(start + 4, true);
                        const normalZ = reader.getFloat32(start + 8, true);

                        if (hasColors) {
                            const packedColor = reader.getUint16(start + 48, true);
                            if ((packedColor & 0x8000) === 0) {
                                r = (packedColor & 0x1F) / 31;
                                g = ((packedColor >> 5) & 0x1F) / 31;
                                b = ((packedColor >> 10) & 0x1F) / 31;
                            } else {
                                r = defaultR;
                                g = defaultG;
                                b = defaultB;
                            }
                        }

                        for (let i = 1; i <= 3; i++) {
                            const vertexstart = start + i * 12;
                            const componentIdx = (face * 3 * 3) + ((i - 1) * 3);
                            vertices[componentIdx] = reader.getFloat32(vertexstart, true);
                            vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);
                            vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);
                            normals[componentIdx] = normalX;
                            normals[componentIdx + 1] = normalY;
                            normals[componentIdx + 2] = normalZ;

                            if (hasColors) {
                                colors[(face * 3 * 3) + ((i - 1) * 3)] = r;
                                colors[(face * 3 * 3) + ((i - 1) * 3) + 1] = g;
                                colors[(face * 3 * 3) + ((i - 1) * 3) + 2] = b;
                            }
                        }
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

                    if (hasColors) {
                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        geometry.hasColors = true;
                        geometry.alpha = alpha;
                    }

                    return geometry;
                }

                function parseASCII(data) {
                    const geometry = new THREE.BufferGeometry();
                    const patternSolid = /solid([\s\S]*?)endsolid/g;
                    const patternFace = /facet[\s]+normal[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+outer[\s]+loop([\s\S]*?)endloop[\s]+endfacet/g;
                    const patternFloat = /[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/g;

                    const vertices = [];
                    const normals = [];

                    const normal = new THREE.Vector3();

                    let result;

                    while ((result = patternSolid.exec(data)) !== null) {
                        const solid = result[0];

                        while ((result = patternFace.exec(solid)) !== null) {
                            let vertexCountPerFace = 0;
                            let normalCountPerFace = 0;

                            const text = result[0];

                            while ((result = patternFloat.exec(text)) !== null) {
                                if (normalCountPerFace < 3) {
                                    normal.x = parseFloat(result[1]);
                                    normal.y = parseFloat(result[3]);
                                    normal.z = parseFloat(result[5]);
                                    normalCountPerFace++;
                                } else {
                                    vertices.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));
                                    normals.push(normal.x, normal.y, normal.z);
                                    vertexCountPerFace++;

                                    if (vertexCountPerFace % 3 === 0) {
                                        patternFloat.lastIndex = 0;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

                    return geometry;
                }

                if (data instanceof ArrayBuffer) {
                    return isBinary(data) ? parseBinary(data) : parseASCII(new TextDecoder().decode(data));
                } else {
                    return parseASCII(data);
                }
            }
        }

        let scene, camera, renderer, currentMesh;
        
        function init() {
            updateStatus("🔧 Initializing Three.js scene...");
            
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e293b);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                75, 
                container.clientWidth / container.clientHeight, 
                0.01, 
                1000
            );
            camera.position.set(0.2, 0.2, 0.2);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add coordinate axes for reference
            const axesHelper = new THREE.AxesHelper(0.1);
            scene.add(axesHelper);
            
            // Simple camera controls
            setupControls();
            
            // Start render loop
            animate();
            
            updateStatus("✅ Scene initialized. Click a button to load an STL file.\n\nRed=X, Green=Y, Blue=Z axes shown for reference.");
        }
        
        function setupControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let cameraRadius = 0.4;
            let cameraTheta = Math.PI / 4;
            let cameraPhi = Math.PI / 4;
            
            const canvas = document.getElementById('canvas');
            
            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    cameraTheta += deltaX * 0.01;
                    cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + deltaY * 0.01));
                    
                    updateCameraPosition();
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                cameraRadius = Math.max(0.1, Math.min(2, cameraRadius + e.deltaY * 0.001));
                updateCameraPosition();
                e.preventDefault();
            });
            
            function updateCameraPosition() {
                camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
                camera.position.y = cameraRadius * Math.cos(cameraPhi);
                camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
                camera.lookAt(0, 0, 0);
            }
            
            updateCameraPosition();
        }
        
        function loadSTL(filename) {
            updateStatus(`🔄 Loading ${filename}...\nFetching from server...`);
            
            // Clear previous mesh
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }
            
            // Load STL using our inlined STLLoader
            const loader = new STLLoader();
            const url = `/api/assets/robot/so101/${filename}`;
            
            loader.load(
                url,
                function (geometry) {
                    updateStatus(`🔄 ${filename} loaded! Processing geometry...\nVertices: ${geometry.attributes.position.count}`);
                    
                    // Create material
                    const material = new THREE.MeshLambertMaterial({ 
                        color: filename.includes('sts3215') ? 0x202020 : 0xFFD700,
                        side: THREE.DoubleSide
                    });
                    
                    // Create mesh
                    currentMesh = new THREE.Mesh(geometry, material);
                    currentMesh.castShadow = true;
                    currentMesh.receiveShadow = true;
                    
                    // Center the geometry
                    geometry.computeBoundingBox();
                    const box = geometry.boundingBox;
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    updateStatus(`🔄 Processing...\nBounding box: ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}`);
                    
                    geometry.translate(-center.x, -center.y, -center.z);
                    
                    // Scale if needed
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0.5) {
                        const scale = 0.5 / maxDim;
                        currentMesh.scale.setScalar(scale);
                        updateStatus(`🔄 Scaling by ${scale.toFixed(3)}...`);
                    }
                    
                    scene.add(currentMesh);
                    
                    updateStatus(`✅ ${filename} loaded successfully!\nVertices: ${geometry.attributes.position.count}\nSize: ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}\nColor: ${filename.includes('sts3215') ? 'Dark (Motor)' : 'Gold (3D Printed)'}`);
                },
                function (progress) {
                    if (progress.lengthComputable) {
                        const percent = (progress.loaded / progress.total * 100);
                        updateStatus(`🔄 Loading ${filename}... ${percent.toFixed(1)}%\nDownloaded: ${progress.loaded} / ${progress.total} bytes`);
                    } else {
                        updateStatus(`🔄 Loading ${filename}...\nDownloaded: ${progress.loaded} bytes`);
                    }
                },
                function (error) {
                    console.error('Error loading STL:', error);
                    updateStatus(`❌ Failed to load ${filename}\nError: ${error.message || error}\n\nCheck browser console for details.`);
                }
            );
        }
        
        function clearScene() {
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
                updateStatus("🧹 Scene cleared.");
            }
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log(message);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // Initialize immediately
        init();
    </script>
</body>
</html>
