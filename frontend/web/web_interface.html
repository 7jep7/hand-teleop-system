<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Teleop - Real-time Tracking</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    
    <!-- Three.js and Physics Libraries -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <!-- OrbitControls as inline script -->
    <script>
        // Simple camera controls to replace OrbitControls if needed
        class SimpleCameraControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3(0, 0, 0.3);
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                
                this.isMouseDown = false;
                this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.domElement.addEventListener('wheel', (e) => this.onMouseWheel(e));
            }
            
            onMouseDown(event) {
                this.isMouseDown = true;
                this.lastMousePosition = { x: event.clientX, y: event.clientY };
            }
            
            onMouseMove(event) {
                if (!this.isMouseDown) return;
                
                const deltaX = event.clientX - this.lastMousePosition.x;
                const deltaY = event.clientY - this.lastMousePosition.y;
                
                this.sphericalDelta.theta -= deltaX * 0.01;
                this.sphericalDelta.phi -= deltaY * 0.01;
                
                this.lastMousePosition = { x: event.clientX, y: event.clientY };
            }
            
            onMouseUp(event) {
                this.isMouseDown = false;
            }
            
            onMouseWheel(event) {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                this.camera.position.multiplyScalar(scale);
            }
            
            update() {
                // Simple orbit behavior
                if (this.sphericalDelta.theta !== 0 || this.sphericalDelta.phi !== 0) {
                    const offset = new THREE.Vector3().copy(this.camera.position).sub(this.target);
                    this.spherical.setFromVector3(offset);
                    
                    this.spherical.theta += this.sphericalDelta.theta;
                    this.spherical.phi += this.sphericalDelta.phi;
                    
                    this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
                    
                    offset.setFromSpherical(this.spherical);
                    this.camera.position.copy(this.target).add(offset);
                    this.camera.lookAt(this.target);
                    
                    if (this.enableDamping) {
                        this.sphericalDelta.theta *= (1 - this.dampingFactor);
                        this.sphericalDelta.phi *= (1 - this.dampingFactor);
                    } else {
                        this.sphericalDelta.set(0, 0, 0);
                    }
                }
            }
        }
        
        // Make it available on THREE namespace for compatibility
        if (typeof THREE !== 'undefined') {
            THREE.OrbitControls = SimpleCameraControls;
        }
    </script>
    <style>
        .camera-container {
            position: relative;
            background: #1f2937;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .processing {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .capture-btn {
            transition: all 0.3s ease;
        }
        .capture-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        .capture-btn:disabled {
            transform: none;
            box-shadow: none;
        }
        .result-fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .loading-spinner {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .analytics-panel {
            transition: all 0.3s ease-in-out;
        }
        
        .robot-status-connected {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        .joint-value {
            transition: all 0.2s ease;
        }
        
        .model-toggle {
            transition: all 0.2s ease;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900 mb-2">Hand Teleop System</h1>
            <p class="text-gray-600 text-lg">Real-time fingertip tracking for robot control</p>
            
            <!-- Model Selection -->
            <div class="mt-4 flex justify-center items-center space-x-4">
                <label class="text-sm font-medium text-gray-700">Tracking Model:</label>
                <div class="flex bg-gray-100 rounded-lg p-1">
                    <button id="mediapipeBtn" class="px-4 py-2 text-sm font-medium rounded-md bg-blue-600 text-white transition-colors">
                        MediaPipe
                    </button>
                    <button id="wilorBtn" class="px-4 py-2 text-sm font-medium rounded-md text-gray-600 hover:text-gray-800 transition-colors">
                        WiLoR
                    </button>
                </div>
                <span id="modelStatus" class="text-sm text-blue-600 font-medium">Live Tracking</span>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="max-w-7xl mx-auto">
            <!-- Robot Control View (Main/Primary) -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-semibold text-gray-800 flex items-center">
                        <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 9.172V5L8 4z"></path>
                        </svg>
                        Robot Control
                    </h2>
                    
                    <!-- Robot Model Selection -->
                    <div class="flex items-center space-x-3">
                        <label class="text-sm font-medium text-gray-700">Manipulator:</label>
                        <select id="robotSelect" class="border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            <option value="so-101">SO-101 (6-DoF)</option>
                            <option value="so-100">SO-100 (5-DoF)</option>
                            <option value="koch">Koch v1.1</option>
                            <option value="moss">MOSS</option>
                            <option value="custom">Custom URDF</option>
                        </select>
                    </div>
                </div>
                
                <!-- Robot Visualization Area -->
                <div class="space-y-6">
                    <!-- 3D Robot View -->
                    <div class="w-full">
                        <div class="bg-gray-900 rounded-lg h-80 md:h-96 relative overflow-hidden">
                            <canvas id="robotCanvas" class="w-full h-full rounded-lg"></canvas>
                            <div id="robotLoadingOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center text-white">
                                <div class="text-center">
                                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white mx-auto mb-2"></div>
                                    <div>Loading robot model...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Robot Status & Controls -->
                    <!-- Control Buttons -->
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-2 mb-4">
                        <button id="robotTrackingToggle" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg text-sm transition-colors">
                            Start Hand Tracking
                        </button>
                        <button id="connectRobot" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-lg text-sm transition-colors">
                            Enable Hand Control
                        </button>
                        <button id="homeRobot" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-3 rounded-lg text-sm transition-colors">
                            Reset Position
                        </button>
                        <button id="addObject" class="bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-2 px-3 rounded-lg text-sm transition-colors">
                            Demo Movement
                        </button>
                        <button id="emergencyStop" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-3 rounded-lg text-sm transition-colors col-span-2 md:col-span-1">
                            Stop All Motion
                        </button>
                    </div>
                    
                    <div class="grid md:grid-cols-3 gap-4">
                        <!-- Robot Status -->
                        <div class="bg-gray-50 rounded-lg p-3">
                            <h4 class="font-semibold text-gray-800 mb-2 text-sm">System Status</h4>
                            <div class="space-y-1 text-xs">
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Hand Tracking:</span>
                                    <span id="robotConnection" class="font-medium text-red-600">Inactive</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Robot Model:</span>
                                    <span id="robotModel" class="font-medium text-gray-800">SO-101</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Control Mode:</span>
                                    <span id="trackingStatus" class="font-medium text-gray-600">Simulation</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Joint Positions -->
                        <div class="bg-gray-50 rounded-lg p-3">
                            <h4 class="font-semibold text-gray-800 mb-2 text-sm">Joint Positions</h4>
                            <div class="space-y-1 text-xs">
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Base:</span>
                                    <span id="joint0" class="font-mono text-gray-800">0.0°</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Shoulder:</span>
                                    <span id="joint1" class="font-mono text-gray-800">0.0°</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Elbow:</span>
                                    <span id="joint2" class="font-mono text-gray-800">0.0°</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Wrist 1:</span>
                                    <span id="joint3" class="font-mono text-gray-800">0.0°</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Wrist 2:</span>
                                    <span id="joint4" class="font-mono text-gray-800">0.0°</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-600">Wrist 3:</span>
                                    <span id="joint5" class="font-mono text-gray-800">0.0°</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- End Effector Position -->
                        <div class="bg-blue-50 rounded-lg p-3">
                            <h4 class="font-semibold text-blue-800 mb-2 text-sm">End Effector</h4>
                            <div class="space-y-1 text-xs">
                                <div class="flex justify-between">
                                    <span class="text-blue-600">X Position:</span>
                                    <span id="endEffectorX" class="font-mono text-blue-800">0.000 m</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-blue-600">Y Position:</span>
                                    <span id="endEffectorY" class="font-mono text-blue-800">0.000 m</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-blue-600">Z Position:</span>
                                    <span id="endEffectorZ" class="font-mono text-blue-800">0.000 m</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-blue-600">Gripper:</span>
                                    <span id="gripperState" class="font-mono text-blue-800">Open</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Analytics Panel (Foldable) -->
            <div class="bg-white rounded-lg shadow-lg overflow-hidden">
                <button id="analyticsToggle" class="w-full px-6 py-4 bg-gray-50 hover:bg-gray-100 transition-colors flex items-center justify-between">
                    <div class="flex items-center">
                        <svg class="w-5 h-5 mr-2 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        <h3 class="text-lg font-semibold text-gray-800">Analytics & Camera View</h3>
                    </div>
                    <svg id="analyticsChevron" class="w-5 h-5 text-gray-600 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                
                <div id="analyticsContent" class="">
                    <div class="p-6">
                        <div class="grid lg:grid-cols-2 gap-8">
            <!-- Left Side - Camera Feed -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                    </svg>
                    Live Camera Feed
                </h2>
                
                <!-- Camera Display -->
                <div class="camera-container mb-4">
                    <video id="videoElement" autoplay playsinline class="w-full h-64 object-cover rounded"></video>
                    <canvas id="outputCanvas" class="absolute top-0 left-0 w-full h-64 rounded"></canvas>
                    <canvas id="captureCanvas" class="hidden"></canvas>
                </div>
                
                <!-- Controls -->
                <div class="space-y-4">
                    <button id="startCamera" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg capture-btn">
                        Start Live Tracking
                    </button>
                    
                    <button id="captureBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg capture-btn disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                        Capture & Process (WiLoR)
                    </button>
                    
                    <!-- Fingertip Display -->
                    <div id="fingertipData" class="hidden bg-gray-50 rounded-lg p-4">
                        <h4 class="font-semibold text-gray-800 mb-2">Live Fingertips:</h4>
                        <div class="grid grid-cols-3 gap-2 text-xs">
                            <div class="bg-yellow-100 p-2 rounded">
                                <div class="font-medium text-yellow-800">Thumb Tip</div>
                                <div id="thumbCoords" class="text-yellow-600">-</div>
                            </div>
                            <div class="bg-blue-100 p-2 rounded">
                                <div class="font-medium text-blue-800">Index PIP</div>
                                <div id="pipCoords" class="text-blue-600">-</div>
                            </div>
                            <div class="bg-red-100 p-2 rounded">
                                <div class="font-medium text-red-800">Index Tip</div>
                                <div id="tipCoords" class="text-red-600">-</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Status -->
                    <div id="status" class="text-center p-3 rounded-lg bg-blue-50 text-blue-700">
                        Click "Start Camera" to begin
                    </div>
                </div>
            </div>
            
            <!-- Right Side - Results -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                    </svg>
                    Tracking Results
                </h2>
                
                <!-- Results Display -->
                <div id="resultsContainer" class="space-y-4">
                    <!-- Default State -->
                    <div id="defaultState" class="text-center py-8">
                        <div class="w-16 h-16 mx-auto mb-4 bg-gray-200 rounded-full flex items-center justify-center">
                            <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4V2a1 1 0 011-1h8a1 1 0 011 1v2m-9 4h10m-10 0V7a2 2 0 012-2h6a2 2 0 012 2v1m-10 0v10a2 2 0 002 2h6a2 2 0 002-2V8"></path>
                            </svg>
                        </div>
                        <p class="text-gray-600">Start live tracking to see real-time fingertip positions</p>
                    </div>
                    
                    <!-- Live Tracking State -->
                    <div id="liveState" class="hidden">
                        <div class="bg-green-50 rounded-lg p-4 mb-4">
                            <div class="flex items-center mb-2">
                                <div class="w-3 h-3 bg-green-500 rounded-full mr-2 animate-pulse"></div>
                                <span class="text-green-800 font-medium">Live Tracking Active</span>
                                <span id="fps" class="ml-auto text-green-600 text-sm">- FPS</span>
                            </div>
                            <div class="text-green-700 text-sm">
                                Show your hand to see real-time fingertip detection
                            </div>
                        </div>
                        
                        <!-- Robot Control Preview -->
                        <div id="robotPreview" class="hidden bg-blue-50 rounded-lg p-4 mb-4">
                            <h4 class="font-semibold text-blue-800 mb-2">Robot Control Mapping:</h4>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div class="text-blue-700">X Position: <span id="robotX" class="font-mono">0.0</span></div>
                                <div class="text-blue-700">Y Position: <span id="robotY" class="font-mono">0.0</span></div>
                                <div class="text-blue-700">Z Position: <span id="robotZ" class="font-mono">0.0</span></div>
                                <div class="text-blue-700">Gripper: <span id="robotGripper" class="font-mono">Open</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Processing State -->
                    <div id="processingState" class="hidden text-center py-8">
                        <div class="loading-spinner mx-auto mb-4"></div>
                        <p class="text-blue-600 font-medium">Processing with WiLoR...</p>
                        <p class="text-gray-500 text-sm mt-2">This may take 20-30 seconds on first run</p>
                    </div>
                    
                    <!-- Results State -->
                    <div id="resultsState" class="hidden">
                        <div id="overlayContainer" class="mb-4">
                            <img id="overlayImage" class="w-full rounded-lg shadow-md" alt="Hand tracking overlay">
                        </div>
                        
                        <div id="handData" class="bg-gray-50 rounded-lg p-4">
                            <h3 class="font-semibold text-gray-800 mb-2">Detection Results:</h3>
                            <div id="handStats" class="text-sm text-gray-600 space-y-1">
                                <!-- Hand statistics will be populated here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Error State -->
                    <div id="errorState" class="hidden text-center py-8">
                        <div class="w-16 h-16 mx-auto mb-4 bg-red-100 rounded-full flex items-center justify-center">
                            <svg class="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <p id="errorMessage" class="text-red-600 font-medium"></p>
                    </div>
                </div>
                
                <!-- Instructions -->
                <div class="mt-6 bg-blue-50 rounded-lg p-4">
                    <h4 class="font-semibold text-blue-800 mb-2">How to use:</h4>
                    <ul class="text-blue-700 text-sm space-y-1">
                        <li>• <strong>Live Tracking:</strong> Real-time fingertip detection with MediaPipe</li>
                        <li>• <strong>WiLoR Processing:</strong> High-quality capture analysis</li>
                        <li>• Position your <strong>RIGHT hand</strong> in the camera view</li>
                        <li>• Three key points: Thumb tip, Index PIP, Index tip</li>
                    </ul>
                    
                    <h4 class="font-semibold text-blue-800 mt-4 mb-2">Overlay Legend:</h4>
                    <ul class="text-blue-700 text-sm space-y-1">
                        <li>• <span class="inline-block w-3 h-3 bg-yellow-400 rounded-full mr-2"></span>Yellow = Thumb tip</li>
                        <li>• <span class="inline-block w-3 h-3 bg-blue-500 rounded-full mr-2"></span>Blue = Index PIP joint</li>
                        <li>• <span class="inline-block w-3 h-3 bg-red-500 rounded-full mr-2"></span>Red = Index fingertip</li>
                    </ul>
                </div>
            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 3D Robot Visualization with Three.js and Cannon.js Physics
        class RobotVisualization {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.loadingOverlay = document.getElementById('robotLoadingOverlay');
                
                // Three.js setup
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                // Physics setup
                this.world = null;
                this.robotBodies = [];
                
                // Robot state
                this.robotType = 'so-101';
                this.jointAngles = [0, 0, 0, 0, 0, 0];
                this.endEffectorTarget = { x: 0, y: 0, z: 0.5 };
                
                // Robot parts
                this.robotParts = {};
                this.joints = [];
                
                // Objects in scene
                this.objects = [];
                
                this.init();
            }
            
            async init() {
                try {
                    console.log('Initializing robot visualization...');
                    console.log('THREE available:', typeof THREE);
                    console.log('CANNON available:', typeof CANNON);
                    console.log('Canvas element:', this.canvas);
                    
                    if (!this.canvas) {
                        throw new Error('Canvas element not found');
                    }
                    
                    if (typeof THREE === 'undefined') {
                        throw new Error('THREE.js not loaded');
                    }
                    
                    this.initThreeJS();
                    console.log('Three.js initialized successfully');
                    
                    // Skip physics for minimal professional setup
                    this.world = null;
                    console.log('Physics disabled for minimal setup');
                    
                    await this.loadRobot();
                    console.log('Robot loaded successfully');
                    
                    this.setupLighting();
                    console.log('Lighting setup complete');
                    
                    this.setupEnvironment();
                    console.log('Environment setup complete');
                    
                    this.animate();
                    console.log('Animation started');
                    
                    // Hide loading overlay
                    if (this.loadingOverlay) {
                        this.loadingOverlay.style.display = 'none';
                    }
                    
                    console.log('Robot visualization initialized successfully');
                } catch (error) {
                    console.error('Error initializing robot visualization:', error);
                    console.error('Error stack:', error.stack);
                    this.showError(`Failed to load robot visualization: ${error.message}`);
                }
            }
            
            initThreeJS() {
                // Scene - clean bright background
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf8fafc); // Very light gray/white
                
                // Camera - positioned for nice robot view
                this.camera = new THREE.PerspectiveCamera(
                    45, // Narrower FOV for more professional look
                    this.canvas.clientWidth / this.canvas.clientHeight,
                    0.1,
                    100
                );
                this.camera.position.set(0.8, 0.8, 0.7);
                this.camera.lookAt(0, 0, 0.25);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Controls - disabled for fixed professional view
                this.controls = null; // Disable camera controls for stationary robot view
                console.log('Camera controls disabled for fixed view');
                
                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            initPhysics() {
                // Cannon.js world
                this.world = new CANNON.World();
                this.world.gravity.set(0, 0, -9.82); // Z-up coordinate system
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;
                
                // Ground plane
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.position.set(0, 0, 0);
                this.world.add(groundBody);
            }
            
            async loadRobot() {
                // Create a procedural robot model (SO-101 style)
                this.createProceduralRobot();
            }
            
            createProceduralRobot() {
                const robotGroup = new THREE.Group();
                robotGroup.name = 'robot';
                
                // Professional material colors
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x2d3748 }); // Dark blue-gray
                const linkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a5568 }); // Medium gray
                const jointMaterial = new THREE.MeshLambertMaterial({ color: 0x1a202c }); // Very dark gray
                const endEffectorMaterial = new THREE.MeshLambertMaterial({ color: 0xe53e3e }); // Distinct red for end-effector
                
                // Create nested groups for proper joint hierarchy
                const baseGroup = new THREE.Group();
                const link1Group = new THREE.Group();
                const link2Group = new THREE.Group();
                const link3Group = new THREE.Group();
                const wristGroup = new THREE.Group();
                
                // Base (fixed)
                const baseGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.08, 16);
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(0, 0, 0.04);
                baseGroup.add(base);
                
                // Link 1 - Shoulder joint (rotates with base)
                const link1Geometry = new THREE.CylinderGeometry(0.04, 0.04, 0.12, 12);
                const link1 = new THREE.Mesh(link1Geometry, jointMaterial);
                link1.position.set(0, 0, 0.10); // Relative to base
                link1Group.add(link1);
                
                // Link 2 - Upper arm (connected to link1)
                const link2Geometry = new THREE.BoxGeometry(0.25, 0.035, 0.05);
                const link2 = new THREE.Mesh(link2Geometry, linkMaterial);
                link2.position.set(0.125, 0, 0.06); // Relative to link1
                link2Group.add(link2);
                
                // Elbow joint (at end of upper arm)
                const elbowGeometry = new THREE.SphereGeometry(0.025, 12, 8);
                const elbow = new THREE.Mesh(elbowGeometry, jointMaterial);
                elbow.position.set(0.25, 0, 0.06); // At end of upper arm
                link2Group.add(elbow);
                
                // Link 3 - Forearm (connected to elbow)
                const link3Geometry = new THREE.BoxGeometry(0.18, 0.03, 0.04);
                const link3 = new THREE.Mesh(link3Geometry, linkMaterial);
                link3.position.set(0.09, 0, 0); // Relative to elbow
                link3Group.add(link3);
                
                // Wrist assembly (at end of forearm)
                const wristGeometry = new THREE.BoxGeometry(0.06, 0.04, 0.04);
                const wrist = new THREE.Mesh(wristGeometry, jointMaterial);
                wrist.position.set(0.18, 0, 0); // At end of forearm
                wristGroup.add(wrist);
                
                // End effector - distinct color
                const gripperBase = new THREE.BoxGeometry(0.05, 0.025, 0.08);
                const gripper = new THREE.Mesh(gripperBase, endEffectorMaterial);
                gripper.position.set(0.05, 0, 0); // Relative to wrist
                wristGroup.add(gripper);
                
                // Gripper fingers - same end-effector color
                const fingerGeometry = new THREE.BoxGeometry(0.02, 0.008, 0.025);
                const finger1 = new THREE.Mesh(fingerGeometry, endEffectorMaterial);
                finger1.position.set(0.075, 0.015, 0);
                wristGroup.add(finger1);
                
                const finger2 = new THREE.Mesh(fingerGeometry, endEffectorMaterial);
                finger2.position.set(0.075, -0.015, 0);
                wristGroup.add(finger2);
                
                // Build hierarchy: base -> link1 -> link2 -> link3 -> wrist
                baseGroup.add(link1Group);
                link1Group.position.set(0, 0, 0.08);
                
                link1Group.add(link2Group);
                link2Group.position.set(0, 0, 0.06);
                
                link2Group.add(link3Group);
                link3Group.position.set(0.25, 0, 0);
                
                link3Group.add(wristGroup);
                wristGroup.position.set(0.18, 0, 0);
                
                robotGroup.add(baseGroup);
                
                // Store robot parts and groups for animation
                this.robotParts = {
                    base: base,
                    baseGroup: baseGroup,
                    link1: link1,
                    link1Group: link1Group,
                    link2: link2,
                    link2Group: link2Group,
                    elbow: elbow,
                    link3: link3,
                    link3Group: link3Group,
                    wrist: wrist,
                    wristGroup: wristGroup,
                    gripper: gripper,
                    finger1: finger1,
                    finger2: finger2
                };
                
                this.scene.add(robotGroup);
            }
            
            addRobotPhysics() {
                // Only add physics if world is available
                if (!this.world) return;
                
                // Add physics bodies for each robot part
                // This is simplified - in a real implementation you'd have proper joint constraints
                
                try {
                    // Base physics body
                    const baseShape = new CANNON.Cylinder(0.08, 0.1, 0.1, 8);
                    const baseBody = new CANNON.Body({ mass: 10 });
                    baseBody.addShape(baseShape);
                    baseBody.position.set(0, 0, 0.05);
                    this.world.add(baseBody);
                    this.robotBodies.push(baseBody);
                } catch (error) {
                    console.warn('Failed to add robot physics:', error.message);
                }
            }
            
            setupLighting() {
                // Clean, professional lighting setup
                
                // Soft ambient light for overall illumination
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                // Main directional light (key light)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(3, 4, 5);
                this.scene.add(directionalLight);
                
                // Fill light from opposite side
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight.position.set(-2, -1, 3);
                this.scene.add(fillLight);
            }
            
            setupEnvironment() {
                // Very minimal environment - just a subtle ground reference
                
                // Simple ground plane - very subtle
                const groundGeometry = new THREE.PlaneGeometry(3, 3);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.1
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.z = 0;
                this.scene.add(ground);
                
                // Minimal grid - very subtle reference
                const gridHelper = new THREE.GridHelper(1, 10, 0xe2e8f0, 0xf1f5f9);
                gridHelper.rotation.x = Math.PI / 2;
                gridHelper.position.z = 0.001;
                this.scene.add(gridHelper);
                
                // Small coordinate frame for reference
                const axesHelper = new THREE.AxesHelper(0.15);
                axesHelper.position.set(-0.4, -0.4, 0.01);
                this.scene.add(axesHelper);
            }
            
            updateRobotPose(jointAngles) {
                this.jointAngles = jointAngles;
                
                if (!this.robotParts.baseGroup) return;
                
                // Proper forward kinematics with joint hierarchy
                const [j0, j1, j2, j3, j4, j5] = jointAngles.map(a => a * Math.PI / 180);
                
                // Joint 0: Base rotation (around Z-axis)
                this.robotParts.baseGroup.rotation.z = j0;
                
                // Joint 1: Shoulder (around Y-axis, relative to base)
                this.robotParts.link1Group.rotation.y = j1;
                
                // Joint 2: Elbow (around Y-axis, relative to upper arm)
                this.robotParts.link2Group.rotation.y = j2;
                
                // Joint 3: Forearm twist (around X-axis, relative to forearm)
                this.robotParts.link3Group.rotation.x = j3;
                
                // Joint 4: Wrist bend (around Y-axis, relative to forearm)
                this.robotParts.wristGroup.rotation.y = j4;
                
                // Joint 5: Wrist twist (around X-axis, relative to wrist)
                this.robotParts.wristGroup.rotation.x += j5; // Additive for compound rotation
            }
            
            updateGripperState(isOpen) {
                if (!this.robotParts.finger1 || !this.robotParts.finger2) return;
                
                const offset = isOpen ? 0.015 : 0.005;
                this.robotParts.finger1.position.y = offset;
                this.robotParts.finger2.position.y = -offset;
            }
            
            addObject(type = 'cube', position = { x: 0.4, y: 0, z: 0.1 }) {
                let geometry, material, mesh, body = null;
                
                switch (type) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(0.03, 16, 12);
                        material = new THREE.MeshPhongMaterial({ color: 0x10b981 });
                        break;
                    case 'cube':
                    default:
                        geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
                        material = new THREE.MeshPhongMaterial({ color: 0xf59e0b });
                        break;
                }
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(position.x, position.y, position.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                
                // Add physics body if physics world is available
                if (this.world) {
                    try {
                        const shape = type === 'sphere' ? 
                            new CANNON.Sphere(0.03) : 
                            new CANNON.Box(new CANNON.Vec3(0.025, 0.025, 0.025));
                        body = new CANNON.Body({ mass: 1 });
                        body.addShape(shape);
                        body.position.set(position.x, position.y, position.z);
                        this.world.add(body);
                    } catch (error) {
                        console.warn('Failed to add physics body for object:', error.message);
                        body = null;
                    }
                }
                
                this.objects.push({ mesh, body });
                
                return { mesh, body };
            }
            
            animate() {
                // Throttle animation to prevent overload
                const now = performance.now();
                if (this.lastRender && now - this.lastRender < 16) { // Cap at ~60 FPS
                    requestAnimationFrame(() => this.animate());
                    return;
                }
                this.lastRender = now;
                
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                if (this.controls) {
                    this.controls.update();
                }
                
                // Render with basic frustum culling
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                if (!this.canvas.clientWidth || !this.canvas.clientHeight) return;
                
                this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
            }
            
            showError(message) {
                if (this.loadingOverlay) {
                    this.loadingOverlay.innerHTML = `
                        <div class="text-center">
                            <div class="text-red-500 mb-2">⚠️</div>
                            <div class="text-red-300">${message}</div>
                        </div>
                    `;
                }
            }
            
            getRobotConfig(robotType) {
                const configs = {
                    'so-101': { joints: 6, name: 'SO-101' },
                    'so-100': { joints: 5, name: 'SO-100' },
                    'koch': { joints: 6, name: 'Koch v1.1' },
                    'moss': { joints: 4, name: 'MOSS' }
                };
                return configs[robotType] || configs['so-101'];
            }
            
            switchRobot(robotType) {
                this.robotType = robotType;
                console.log(`Switched to ${robotType} robot model`);
                // In a full implementation, you'd reload the robot model here
            }
        }
        
        // Client-side hand tracking with MediaPipe
        class HandTeleopTracker {
            constructor() {
                this.hands = null;
                this.camera = null;
                this.isTracking = false;
                this.currentModel = 'mediapipe'; // 'mediapipe' or 'wilor'
                this.analyticsVisible = false;
                this.isBasicCamera = false; // Flag for fallback camera mode
                this.fingertips = { thumb: null, indexPip: null, indexTip: null };
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                // Robot visualization
                this.robotViz = null;
                
                // DOM elements
                this.videoElement = document.getElementById('videoElement');
                this.outputCanvas = document.getElementById('outputCanvas');
                this.captureCanvas = document.getElementById('captureCanvas');
                this.ctx = this.outputCanvas.getContext('2d');
                
                this.initializeElements();
                this.initializeRobotVisualization();
            }
            
            initializeElements() {
                // Original elements
                this.startBtn = document.getElementById('startCamera');
                this.captureBtn = document.getElementById('captureBtn');
                this.statusDiv = document.getElementById('status');
                this.fingertipData = document.getElementById('fingertipData');
                this.defaultState = document.getElementById('defaultState');
                this.liveState = document.getElementById('liveState');
                this.fpsDisplay = document.getElementById('fps');
                
                // Video elements (may be in collapsed panel initially)
                this.videoElement = document.getElementById('videoElement');
                this.outputCanvas = document.getElementById('outputCanvas');
                this.captureCanvas = document.getElementById('captureCanvas');
                
                // Initialize canvas context if available
                if (this.outputCanvas) {
                    this.ctx = this.outputCanvas.getContext('2d');
                }
                
                // Log element availability for debugging
                console.log('Element check:', {
                    startBtn: !!this.startBtn,
                    videoElement: !!this.videoElement,
                    outputCanvas: !!this.outputCanvas,
                    captureCanvas: !!this.captureCanvas
                });
                
                // New UI elements
                this.mediapipeBtn = document.getElementById('mediapipeBtn');
                this.wilorBtn = document.getElementById('wilorBtn');
                this.modelStatus = document.getElementById('modelStatus');
                this.robotSelect = document.getElementById('robotSelect');
                this.analyticsToggle = document.getElementById('analyticsToggle');
                this.analyticsContent = document.getElementById('analyticsContent');
                this.analyticsChevron = document.getElementById('analyticsChevron');
                
                // Robot status elements
                this.robotConnection = document.getElementById('robotConnection');
                this.robotModel = document.getElementById('robotModel');
                this.trackingStatus = document.getElementById('trackingStatus');
                this.robotTrackingToggle = document.getElementById('robotTrackingToggle');
                this.connectRobot = document.getElementById('connectRobot');
                this.homeRobot = document.getElementById('homeRobot');
                this.addObject = document.getElementById('addObject');
                this.emergencyStop = document.getElementById('emergencyStop');
                
                // Joint elements
                this.joints = [
                    document.getElementById('joint0'),
                    document.getElementById('joint1'),
                    document.getElementById('joint2'),
                    document.getElementById('joint3'),
                    document.getElementById('joint4'),
                    document.getElementById('joint5')
                ];
                
                // End effector elements
                this.endEffectorX = document.getElementById('endEffectorX');
                this.endEffectorY = document.getElementById('endEffectorY');
                this.endEffectorZ = document.getElementById('endEffectorZ');
                this.gripperState = document.getElementById('gripperState');
                
                // Coordinate displays
                this.thumbCoords = document.getElementById('thumbCoords');
                this.pipCoords = document.getElementById('pipCoords');
                this.tipCoords = document.getElementById('tipCoords');
                
                // Robot preview elements
                this.robotPreview = document.getElementById('robotPreview');
                this.robotX = document.getElementById('robotX');
                this.robotY = document.getElementById('robotY');
                this.robotZ = document.getElementById('robotZ');
                this.robotGripper = document.getElementById('robotGripper');
                
                this.setupEventListeners();
                this.initializeAnalyticsView();
                
                // Initialize robot display with default SO-101
                this.updateJointDisplay('so-101');
            }
            
            setupEventListeners() {
                console.log('Setting up event listeners...');
                console.log('Start button element:', this.startBtn);
                console.log('Button ID check:', document.getElementById('startCamera'));
                
                // Original event listeners
                if (this.startBtn) {
                    console.log('Adding click listener to start button');
                    this.startBtn.addEventListener('click', (event) => {
                        console.log('Start button clicked! Event:', event);
                        console.log('Button element at click time:', event.target);
                        event.preventDefault();
                        this.toggleTracking();
                    });
                    console.log('Click listener added successfully');
                } else {
                    console.error('Start button not found during setup!');
                    console.log('Available elements with startCamera ID:', document.querySelectorAll('#startCamera'));
                }
                
                if (this.captureBtn) {
                    this.captureBtn.addEventListener('click', () => this.captureAndProcess());
                }
                
                // Model selection
                if (this.mediapipeBtn) {
                    this.mediapipeBtn.addEventListener('click', () => this.switchModel('mediapipe'));
                }
                if (this.wilorBtn) {
                    this.wilorBtn.addEventListener('click', () => this.switchModel('wilor'));
                }
                
                // Robot selection
                if (this.robotSelect) {
                    this.robotSelect.addEventListener('change', (e) => this.selectRobot(e.target.value));
                }
                
                // Analytics toggle
                if (this.analyticsToggle) {
                    this.analyticsToggle.addEventListener('click', () => this.toggleAnalytics());
                }
                
                // Robot controls
                if (this.robotTrackingToggle) {
                    this.robotTrackingToggle.addEventListener('click', () => this.toggleTracking());
                }
                if (this.connectRobot) {
                    this.connectRobot.addEventListener('click', () => this.toggleRobotConnection());
                }
                if (this.homeRobot) {
                    this.homeRobot.addEventListener('click', () => this.homeRobot());
                }
                if (this.addObject) {
                    this.addObject.addEventListener('click', () => this.demoMovement());
                }
                if (this.emergencyStop) {
                    this.emergencyStop.addEventListener('click', () => this.emergencyStop());
                }
            }
            
            initializeAnalyticsView() {
                // Start with analytics visible for easier testing
                this.analyticsVisible = true;
                this.analyticsContent.classList.remove('hidden');
                this.analyticsChevron.style.transform = 'rotate(180deg)';
            }
            
            async debugCameraAccess() {
                console.log('=== Camera Debug Information ===');
                
                // Check if navigator exists
                if (!navigator) {
                    console.error('Navigator object not available');
                    return;
                }
                
                // Check mediaDevices support
                if (!navigator.mediaDevices) {
                    console.error('navigator.mediaDevices not available');
                    console.log('This usually means:');
                    console.log('- You are not using HTTPS (required for camera access)');
                    console.log('- Your browser does not support modern camera APIs');
                    return;
                }
                
                // Check getUserMedia specifically
                if (!navigator.mediaDevices.getUserMedia) {
                    console.error('navigator.mediaDevices.getUserMedia not available');
                    return;
                }
                
                console.log('✓ Camera APIs are available');
                
                // Check for available devices
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const cameras = devices.filter(device => device.kind === 'videoinput');
                    console.log(`Found ${cameras.length} camera(s):`, cameras);
                } catch (error) {
                    console.error('Failed to enumerate devices:', error);
                }
                
                // Check permissions if supported
                if (navigator.permissions) {
                    try {
                        const permission = await navigator.permissions.query({ name: 'camera' });
                        console.log('Camera permission state:', permission.state);
                    } catch (error) {
                        console.log('Could not check camera permissions:', error.message);
                    }
                }
                
                // Test basic camera access
                try {
                    console.log('Testing basic camera access...');
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    console.log('✓ Camera access successful');
                    // Stop the test stream
                    stream.getTracks().forEach(track => track.stop());
                } catch (error) {
                    console.error('✗ Camera access failed:', error.name, error.message);
                    if (error.name === 'NotAllowedError') {
                        console.log('- User denied camera permission');
                    } else if (error.name === 'NotFoundError') {
                        console.log('- No camera device found');
                    } else if (error.name === 'NotReadableError') {
                        console.log('- Camera is being used by another application');
                    }
                }
                
                console.log('=== End Camera Debug ===');
            }

            async initializeRobotVisualization() {
                try {
                    // Wait a bit for DOM to be ready
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    this.robotViz = new RobotVisualization('robotCanvas');
                    console.log('Robot visualization initialized');
                    
                    // Demo robot movements for testing
                    setTimeout(() => {
                        if (this.robotViz) {
                            // Demo some joint movements
                            this.robotViz.updateRobotPose([15, 20, -30, 0, 0, 0]);
                            
                            setTimeout(() => {
                                this.robotViz.updateRobotPose([0, 0, 0, 0, 0, 0]);
                            }, 3000);
                        }
                    }, 2000);
                    
                } catch (error) {
                    console.error('Failed to initialize robot visualization:', error);
                }
            }
            
            switchModel(model) {
                this.currentModel = model;
                
                // Update button states
                if (model === 'mediapipe') {
                    this.mediapipeBtn.className = 'px-4 py-2 text-sm font-medium rounded-md bg-blue-600 text-white transition-colors';
                    this.wilorBtn.className = 'px-4 py-2 text-sm font-medium rounded-md text-gray-600 hover:text-gray-800 transition-colors';
                    this.modelStatus.textContent = 'Live Tracking';
                    this.modelStatus.className = 'text-sm text-blue-600 font-medium';
                } else {
                    this.mediapipeBtn.className = 'px-4 py-2 text-sm font-medium rounded-md text-gray-600 hover:text-gray-800 transition-colors';
                    this.wilorBtn.className = 'px-4 py-2 text-sm font-medium rounded-md bg-purple-600 text-white transition-colors';
                    this.modelStatus.textContent = 'High Quality';
                    this.modelStatus.className = 'text-sm text-purple-600 font-medium';
                }
                
                // Update tracking mode
                if (this.isTracking) {
                    if (model === 'mediapipe') {
                        this.updateStatus('Switched to MediaPipe - Live tracking', 'blue');
                    } else {
                        this.updateStatus('Switched to WiLoR - Capture mode', 'purple');
                        // Stop live tracking for WiLoR mode
                        this.stopLiveTracking();
                    }
                }
                
                console.log(`Switched to ${model} model`);
            }
            
            selectRobot(robotType) {
                this.robotModel.textContent = robotType.toUpperCase();
                console.log(`Selected robot: ${robotType}`);
                
                // Update robot status
                this.updateStatus(`Selected ${robotType} manipulator`, 'blue');
                
                // Update joint display based on robot type
                this.updateJointDisplay(robotType);
                
                // Update 3D robot visualization
                if (this.robotViz) {
                    this.robotViz.switchRobot(robotType);
                }
            }
            
            updateJointDisplay(robotType) {
                // Hide all joints first
                this.joints.forEach(joint => {
                    if (joint && joint.parentElement) {
                        joint.parentElement.style.display = 'none';
                    }
                });
                
                // Define joint configurations for different robots
                const robotConfigs = {
                    'so-101': { joints: 6, names: ['Base', 'Shoulder', 'Elbow', 'Wrist 1', 'Wrist 2', 'Wrist 3'] },
                    'so-100': { joints: 5, names: ['Base', 'Shoulder', 'Elbow', 'Wrist 1', 'Wrist 2'] },
                    'koch': { joints: 6, names: ['Base', 'Shoulder', 'Elbow', 'Wrist 1', 'Wrist 2', 'Wrist 3'] },
                    'moss': { joints: 4, names: ['Base', 'Shoulder', 'Elbow', 'Wrist'] },
                    'custom': { joints: 6, names: ['Joint 1', 'Joint 2', 'Joint 3', 'Joint 4', 'Joint 5', 'Joint 6'] }
                };
                
                const config = robotConfigs[robotType] || robotConfigs['so-101'];
                
                // Show and update labels for active joints
                for (let i = 0; i < config.joints && i < this.joints.length; i++) {
                    if (this.joints[i] && this.joints[i].parentElement) {
                        const parentDiv = this.joints[i].parentElement;
                        parentDiv.style.display = 'flex';
                        
                        // Update joint label
                        const label = parentDiv.querySelector('.text-gray-600');
                        if (label) {
                            label.textContent = config.names[i] + ':';
                        }
                        
                        // Reset joint value
                        this.joints[i].textContent = '0.0°';
                    }
                }
                
                console.log(`Updated joint display for ${robotType}: ${config.joints} joints`);
            }
            
            toggleAnalytics() {
                this.analyticsVisible = !this.analyticsVisible;
                
                if (this.analyticsVisible) {
                    this.analyticsContent.classList.remove('hidden');
                    this.analyticsChevron.style.transform = 'rotate(180deg)';
                } else {
                    this.analyticsContent.classList.add('hidden');
                    this.analyticsChevron.style.transform = 'rotate(0deg)';
                }
                
                console.log(`Analytics view ${this.analyticsVisible ? 'opened' : 'closed'}`);
            }
            
            toggleRobotConnection() {
                const isActive = this.robotConnection.textContent === 'Active';
                
                if (isActive) {
                    // Disable hand control
                    this.robotConnection.textContent = 'Inactive';
                    this.robotConnection.className = 'font-medium text-red-600';
                    this.connectRobot.textContent = 'Enable Hand Control';
                    this.connectRobot.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition-colors';
                    this.updateStatus('Hand control disabled', 'red');
                } else {
                    // Enable hand control
                    this.robotConnection.textContent = 'Active';
                    this.robotConnection.className = 'font-medium text-green-600';
                    this.connectRobot.textContent = 'Disable Hand Control';
                    this.connectRobot.className = 'w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition-colors';
                    this.updateStatus('Hand control enabled', 'green');
                }
            }
            
            updateJointPositions(angles) {
                // Update joint display with new angles
                angles.forEach((angle, index) => {
                    if (this.joints[index]) {
                        this.joints[index].textContent = `${angle.toFixed(1)}°`;
                    }
                });
                
                // Update 3D robot visualization
                if (this.robotViz) {
                    this.robotViz.updateRobotPose(angles);
                }
            }
            
            updateEndEffectorPosition(x, y, z, gripper) {
                this.endEffectorX.textContent = `${x.toFixed(3)} m`;
                this.endEffectorY.textContent = `${y.toFixed(3)} m`;
                this.endEffectorZ.textContent = `${z.toFixed(3)} m`;
                this.gripperState.textContent = gripper;
                
                // Update 3D robot gripper
                if (this.robotViz) {
                    this.robotViz.updateGripperState(gripper === 'Open');
                }
            }
            
            stopLiveTracking() {
                // Stop MediaPipe live tracking when switching to WiLoR
                if (this.camera && this.currentModel === 'wilor') {
                    // Keep camera running but stop MediaPipe processing
                    console.log('Paused live tracking for WiLoR mode');
                }
            }
            
            async initializeMediaPipe() {
                try {
                    // Check if MediaPipe is loaded
                    if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                        console.error('MediaPipe not loaded. Trying to use basic camera...');
                        return await this.initializeBasicCamera();
                    }
                    
                    // Initialize MediaPipe Hands
                    this.hands = new Hands({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                        }
                    });
                    
                    this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    this.hands.onResults((results) => this.onResults(results));
                    
                    // Initialize camera with throttled processing
                    this.camera = new Camera(this.videoElement, {
                        onFrame: async () => {
                            // Throttle MediaPipe processing to prevent overload
                            const now = performance.now();
                            if (this.lastMediaPipeCall && now - this.lastMediaPipeCall < 100) { // Max 10 FPS for MediaPipe
                                return;
                            }
                            this.lastMediaPipeCall = now;
                            
                            if (this.isTracking && this.hands) {
                                await this.hands.send({ image: this.videoElement });
                            }
                        },
                        width: 640,
                        height: 480
                    });
                    
                    return true;
                } catch (error) {
                    console.error('MediaPipe initialization failed:', error);
                    console.log('Falling back to basic camera...');
                    return await this.initializeBasicCamera();
                }
            }
            
            async initializeBasicCamera() {
                try {
                    // Check if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Camera API not available. Try using HTTPS or a different browser.');
                    }

                    // Check current permission state
                    if (navigator.permissions) {
                        try {
                            const permission = await navigator.permissions.query({name: 'camera'});
                            console.log('Camera permission state:', permission.state);
                            
                            if (permission.state === 'denied') {
                                throw new Error('Camera permission denied. Please allow camera access in browser settings.');
                            }
                        } catch (permError) {
                            console.log('Permission API not supported, continuing with camera request...');
                        }
                    }

                    // Try different camera configurations
                    const configs = [
                        { video: { width: 640, height: 480, facingMode: 'user' } },
                        { video: { width: 640, height: 480 } },
                        { video: true },
                        { video: { deviceId: 'default' } }
                    ];

                    let stream = null;
                    let lastError = null;

                    for (const config of configs) {
                        try {
                            console.log('Trying camera config:', config);
                            stream = await navigator.mediaDevices.getUserMedia(config);
                            console.log('Camera access successful with config:', config);
                            break;
                        } catch (error) {
                            console.log('Camera config failed:', config, 'Error:', error.message);
                            lastError = error;
                        }
                    }

                    if (!stream) {
                        throw lastError || new Error('All camera configurations failed');
                    }
                    
                    this.videoElement.srcObject = stream;
                    this.isBasicCamera = true;
                    
                    // Wait for video to be ready
                    return new Promise((resolve) => {
                        this.videoElement.onloadedmetadata = () => {
                            console.log('Basic camera initialized successfully');
                            resolve(true);
                        };
                        this.videoElement.onerror = () => {
                            console.error('Video element error');
                            resolve(false);
                        };
                    });
                    
                } catch (error) {
                    console.error('Basic camera initialization failed:', error);
                    
                    // Provide specific error messages
                    let errorMessage = 'Camera access failed: ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Permission denied. Please allow camera access and refresh the page.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No camera found. Please connect a camera and refresh the page.';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage += 'Camera is busy or hardware error. Try disconnecting/reconnecting your external display.';
                    } else if (error.name === 'OverconstrainedError') {
                        errorMessage += 'Camera settings not supported. Try a different camera.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus('❌ ' + errorMessage, 'red');
                    return false;
                }
            }
            
            async toggleTracking() {
                console.log('toggleTracking called, isTracking:', this.isTracking);
                console.log('Current analytics visibility:', this.analyticsVisible);
                console.log('Video element available:', !!this.videoElement);
                
                if (!this.isTracking) {
                    await this.startTracking();
                } else {
                    this.stopTracking();
                }
            }
            
            async startTracking() {
                // Ensure analytics panel is open so camera elements are accessible
                if (!this.analyticsVisible) {
                    this.showAnalytics();
                    // Give the UI a moment to render the panel
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Debug camera availability
                await this.debugCameraAccess();
                
                this.updateStatus('Initializing camera...', 'blue');
                
                // Refresh video elements after panel is open
                this.refreshVideoElements();
                
                // Check if video element is accessible
                if (!this.videoElement) {
                    console.error('Video element not found after refresh!');
                    this.updateStatus('❌ Video element not found', 'red');
                    return;
                }
                
                if (!this.hands && !this.isBasicCamera && !(await this.initializeMediaPipe())) {
                    this.updateStatus('❌ Failed to initialize camera', 'red');
                    return;
                }
                
                try {
                    if (this.camera && this.camera.start) {
                        // MediaPipe camera
                        await this.camera.start();
                    } else if (this.isBasicCamera) {
                        // Basic camera already initialized
                        console.log('Using basic camera (already initialized)');
                    } else {
                        throw new Error('No camera available');
                    }
                    
                    this.isTracking = true;
                    
                    // Update UI buttons (both analytics and robot panel)
                    this.startBtn.textContent = 'Stop Tracking';
                    this.startBtn.className = 'w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg capture-btn';
                    
                    if (this.robotTrackingToggle) {
                        this.robotTrackingToggle.textContent = 'Stop Hand Tracking';
                        this.robotTrackingToggle.className = 'w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition-colors';
                    }
                    
                    this.captureBtn.disabled = false;
                    
                    if (this.fingertipData) this.fingertipData.classList.remove('hidden');
                    if (this.defaultState) this.defaultState.classList.add('hidden');
                    if (this.liveState) this.liveState.classList.remove('hidden');
                    if (this.robotPreview) this.robotPreview.classList.remove('hidden');
                    
                    // Update tracking status display
                    if (this.trackingStatus) {
                        this.trackingStatus.textContent = 'Active';
                        this.trackingStatus.className = 'font-medium text-green-600';
                    }
                    
                    if (this.hands) {
                        this.updateStatus('✅ MediaPipe tracking active', 'green');
                    } else {
                        this.updateStatus('✅ Basic camera active (MediaPipe unavailable)', 'blue');
                        // Start a basic demo for visual feedback
                        this.startBasicDemo();
                    }
                    
                    // Start FPS counter
                    this.startFPSCounter();
                    
                } catch (error) {
                    console.error('Error starting camera:', error);
                    this.updateStatus('❌ Could not access camera: ' + error.message, 'red');
                }
            }
            
            showAnalytics() {
                this.analyticsVisible = true;
                if (this.analyticsContent) {
                    this.analyticsContent.classList.remove('hidden');
                    console.log('Analytics content visibility toggled, hidden class removed');
                }
                if (this.analyticsChevron) {
                    this.analyticsChevron.style.transform = 'rotate(180deg)';
                }
                
                // Force a reflow to ensure panel is rendered
                if (this.analyticsContent) {
                    this.analyticsContent.offsetHeight;
                }
                
                console.log('Analytics panel opened, forcing video element refresh');
            }
            
            refreshVideoElements() {
                // Re-get video elements in case they weren't accessible before
                if (!this.videoElement) {
                    this.videoElement = document.getElementById('videoElement');
                }
                if (!this.outputCanvas) {
                    this.outputCanvas = document.getElementById('outputCanvas');
                }
                if (!this.captureCanvas) {
                    this.captureCanvas = document.getElementById('captureCanvas');
                }
                
                // Initialize canvas context if now available
                if (this.outputCanvas && !this.ctx) {
                    this.ctx = this.outputCanvas.getContext('2d');
                }
                
                console.log('Video elements refreshed:', {
                    videoElement: !!this.videoElement,
                    outputCanvas: !!this.outputCanvas,
                    captureCanvas: !!this.captureCanvas,
                    ctx: !!this.ctx
                });
            }
            
            startBasicDemo() {
                // Simple demo animation when MediaPipe isn't available
                if (!this.isTracking) return;
                
                const time = performance.now() * 0.001;
                
                // Simulate hand tracking for demo purposes
                this.fingertips = {
                    thumb: { x: 200 + Math.sin(time) * 50, y: 150 + Math.cos(time) * 30, z: 0.3 },
                    indexPip: { x: 250 + Math.sin(time + 1) * 40, y: 180 + Math.cos(time + 1) * 25, z: 0.35 },
                    indexTip: { x: 300 + Math.sin(time + 2) * 60, y: 160 + Math.cos(time + 2) * 35, z: 0.25 }
                };
                
                this.updateCoordinateDisplays();
                this.updateRobotMapping();
                this.updateFPS();
                
                setTimeout(() => this.startBasicDemo(), 33); // ~30 FPS
            }
            
            stopTracking() {
                this.isTracking = false;
                
                if (this.camera) {
                    this.camera.stop();
                }
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
                
                // Update UI buttons (both analytics and robot panel)
                this.startBtn.textContent = 'Start Live Tracking';
                this.startBtn.className = 'w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg capture-btn';
                
                if (this.robotTrackingToggle) {
                    this.robotTrackingToggle.textContent = 'Start Hand Tracking';
                    this.robotTrackingToggle.className = 'w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition-colors';
                }
                
                this.captureBtn.disabled = true;
                
                this.fingertipData.classList.add('hidden');
                this.liveState.classList.add('hidden');
                this.defaultState.classList.remove('hidden');
                this.robotPreview.classList.add('hidden');
                
                this.updateStatus('Tracking stopped', 'blue');
                
                // Update tracking status display  
                if (this.trackingStatus) {
                    this.trackingStatus.textContent = 'Stopped';
                    this.trackingStatus.className = 'font-medium text-gray-600';
                }
            }
            
            onResults(results) {
                if (!this.isTracking) return;
                
                // Throttle UI updates to prevent excessive DOM manipulation
                const now = performance.now();
                if (this.lastUIUpdate && now - this.lastUIUpdate < 50) { // Max 20 FPS for UI updates
                    return;
                }
                this.lastUIUpdate = now;
                
                // Update canvas size only when needed
                if (this.outputCanvas.width !== this.videoElement.videoWidth ||
                    this.outputCanvas.height !== this.videoElement.videoHeight) {
                    this.outputCanvas.width = this.videoElement.videoWidth;
                    this.outputCanvas.height = this.videoElement.videoHeight;
                }
                
                // Clear previous drawings
                this.ctx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Extract our MVP fingertips (MediaPipe landmark indices)
                    // 4 = thumb tip, 6 = index PIP, 8 = index tip
                    const thumbTip = landmarks[4];
                    const indexPip = landmarks[6];
                    const indexTip = landmarks[8];
                    
                    // Convert to pixel coordinates
                    const w = this.outputCanvas.width;
                    const h = this.outputCanvas.height;
                    
                    this.fingertips = {
                        thumb: { x: thumbTip.x * w, y: thumbTip.y * h, z: thumbTip.z },
                        indexPip: { x: indexPip.x * w, y: indexPip.y * h, z: indexPip.z },
                        indexTip: { x: indexTip.x * w, y: indexTip.y * h, z: indexTip.z }
                    };
                    
                    // Draw fingertips
                    this.drawFingertips();
                    
                    // Update displays (throttled)
                    this.updateCoordinateDisplays();
                    this.updateRobotMapping();
                    
                } else {
                    // No hand detected
                    this.fingertips = { thumb: null, indexPip: null, indexTip: null };
                    this.updateCoordinateDisplays();
                }
                
                this.updateFPS();
            }
            
            drawFingertips() {
                const { thumb, indexPip, indexTip } = this.fingertips;
                
                // Draw connections
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(indexPip.x, indexPip.y);
                this.ctx.lineTo(indexTip.x, indexTip.y);
                this.ctx.stroke();
                
                // Draw fingertip points
                this.drawPoint(thumb.x, thumb.y, '#FCD34D', 8); // Yellow - thumb
                this.drawPoint(indexPip.x, indexPip.y, '#3B82F6', 6); // Blue - PIP
                this.drawPoint(indexTip.x, indexTip.y, '#EF4444', 8); // Red - tip
                
                // Draw labels
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.fillText('T', thumb.x - 6, thumb.y + 4);
                this.ctx.fillText('P', indexPip.x - 6, indexPip.y + 4);
                this.ctx.fillText('I', indexTip.x - 6, indexTip.y + 4);
            }
            
            drawPoint(x, y, color, size = 6) {
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // White border
                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }
            
            updateCoordinateDisplays() {
                const { thumb, indexPip, indexTip } = this.fingertips;
                
                this.thumbCoords.textContent = thumb ? 
                    `(${Math.round(thumb.x)}, ${Math.round(thumb.y)})` : 'Not detected';
                this.pipCoords.textContent = indexPip ? 
                    `(${Math.round(indexPip.x)}, ${Math.round(indexPip.y)})` : 'Not detected';
                this.tipCoords.textContent = indexTip ? 
                    `(${Math.round(indexTip.x)}, ${Math.round(indexTip.y)})` : 'Not detected';
            }
            
            updateRobotMapping() {
                const { thumb, indexPip, indexTip } = this.fingertips;
                
                if (thumb && indexPip && indexTip) {
                    // Simple mapping for robot control preview
                    const x = ((indexTip.x / this.outputCanvas.width) - 0.5) * 2; // -1 to 1
                    const y = ((indexTip.y / this.outputCanvas.height) - 0.5) * -2; // -1 to 1 (inverted Y)
                    const z = Math.max(0, indexTip.z * 2); // 0 to 2
                    
                    // Gripper control based on thumb-index distance
                    const distance = Math.sqrt(
                        Math.pow(thumb.x - indexTip.x, 2) + 
                        Math.pow(thumb.y - indexTip.y, 2)
                    );
                    const gripper = distance < 50 ? 'Closed' : 'Open';
                    
                    // Update robot preview (in analytics)
                    if (this.robotX) {
                        this.robotX.textContent = x.toFixed(2);
                        this.robotY.textContent = y.toFixed(2);
                        this.robotZ.textContent = z.toFixed(2);
                        this.robotGripper.textContent = gripper;
                    }
                    
                    // Update main robot display
                    this.updateEndEffectorPosition(x * 0.5, y * 0.5, z * 0.3, gripper);
                    
                    // Generate joint angles (simple IK approximation)
                    const jointAngles = this.calculateJointAngles(x, y, z);
                    this.updateJointPositions(jointAngles);
                    
                } else {
                    // No hand detected - reset to neutral position
                    if (this.robotX) {
                        this.robotX.textContent = '0.0';
                        this.robotY.textContent = '0.0';
                        this.robotZ.textContent = '0.0';
                        this.robotGripper.textContent = 'Open';
                    }
                    this.updateEndEffectorPosition(0, 0, 0, 'Open');
                    this.updateJointPositions([0, 0, 0, 0, 0, 0]);
                }
            }
            
            calculateJointAngles(x, y, z) {
                // Simple inverse kinematics approximation for 6-DOF arm
                // This is a simplified version - real IK would be more complex
                const baseRotation = Math.atan2(y, x) * 180 / Math.PI;
                const shoulderAngle = Math.atan2(z, Math.sqrt(x*x + y*y)) * 180 / Math.PI;
                const elbowAngle = -shoulderAngle * 1.5; // Simple relationship
                const wrist1 = shoulderAngle * 0.5;
                const wrist2 = 0; // Keep straight for simplicity
                const wrist3 = baseRotation * 0.3;
                
                return [baseRotation, shoulderAngle, elbowAngle, wrist1, wrist2, wrist3];
            }
            
            startFPSCounter() {
                this.frameCount = 0;
                this.lastTime = performance.now();
            }
            
            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / (now - this.lastTime));
                    this.fpsDisplay.textContent = `${this.fps} FPS`;
                    this.frameCount = 0;
                    this.lastTime = now;
                }
            }
            
            async captureAndProcess() {
                // Keep the original WiLoR functionality with reduced frequency
                if (!this.isTracking) return;
                
                // Throttle API calls to prevent overload
                const now = performance.now();
                if (this.lastAPICall && now - this.lastAPICall < 500) { // Max 2 calls per second
                    return;
                }
                this.lastAPICall = now;
                
                this.updateStatus('Processing with WiLoR...', 'orange');
                
                try {
                    // Capture current frame
                    const canvas = this.captureCanvas;
                    const context = canvas.getContext('2d');
                    
                    canvas.width = this.videoElement.videoWidth;
                    canvas.height = this.videoElement.videoHeight;
                    context.drawImage(this.videoElement, 0, 0);
                    
                    // Convert to blob with reduced quality for faster processing
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.6));
                    
                    // Create form data
                    const formData = new FormData();
                    formData.append('file', blob, 'capture.jpg');
                    
                    // Send to API with timeout for faster feedback
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1500); // Reduced timeout
                    
                    const response = await fetch('/api/track', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            image_data: canvas.toDataURL('image/jpeg', 0.6), // Reduced quality
                            robot_type: 'so101',
                            tracking_mode: 'wilor'
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.updateStatus('✅ WiLoR processing complete!', 'green');
                        // Handle WiLoR results...
                    } else {
                        this.updateStatus('❌ No hand detected in WiLoR', 'red');
                    }
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('WiLoR backend request timed out');
                        this.updateStatus('⚠️ WiLoR backend unavailable - using live tracking', 'orange');
                    } else {
                        console.log('WiLoR backend not available:', error.message);
                        this.updateStatus('📱 WiLoR offline - live tracking active', 'blue');
                    }
                }
            }
            
            demoMovement() {
                if (!this.robotViz) {
                    this.updateStatus('Robot visualization not available', 'red');
                    return;
                }
                
                this.updateStatus('Running demo movement sequence...', 'blue');
                
                // Demo sequence: move through various joint positions
                const demoSequence = [
                    [0, 0, 0, 0, 0, 0],      // Home
                    [30, 45, -90, 0, 45, 0], // Position 1
                    [-45, 30, -60, 90, 0, 180], // Position 2
                    [60, -30, 45, -45, 90, -90], // Position 3
                    [0, 0, 0, 0, 0, 0]       // Back to home
                ];
                
                let step = 0;
                const moveNext = () => {
                    if (step < demoSequence.length) {
                        const angles = demoSequence[step];
                        this.robotViz.updateRobotPose(angles);
                        this.updateJointPositions(angles);
                        
                        step++;
                        setTimeout(moveNext, 1500); // 1.5 second intervals
                    } else {
                        this.updateStatus('Demo movement complete', 'green');
                    }
                };
                
                moveNext();
            }
            
            updateStatus(message, color) {
                this.statusDiv.textContent = message;
                this.statusDiv.className = 'text-center p-3 rounded-lg';
                
                switch(color) {
                    case 'green':
                        this.statusDiv.classList.add('bg-green-50', 'text-green-700');
                        break;
                    case 'red':
                        this.statusDiv.classList.add('bg-red-50', 'text-red-700');
                        break;
                    case 'orange':
                        this.statusDiv.classList.add('bg-orange-50', 'text-orange-700');
                        break;
                    default:
                        this.statusDiv.classList.add('bg-blue-50', 'text-blue-700');
                }
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing hand tracker...');
            try {
                window.handTracker = new HandTeleopTracker();
                console.log('Hand tracker initialized successfully:', window.handTracker);
                console.log('Toggle tracking method:', typeof window.handTracker.toggleTracking);
                
                // Test button functionality
                console.log('Start button element:', document.getElementById('startCamera'));
                
                // Double-check event listener setup
                const startBtn = document.getElementById('startCamera');
                if (startBtn) {
                    console.log('Button found, adding additional click listener...');
                    startBtn.addEventListener('click', function() {
                        console.log('Secondary click listener fired!');
                    });
                }
            } catch (error) {
                console.error('Error initializing hand tracker:', error);
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.handTracker && window.handTracker.camera) {
                window.handTracker.camera.stop();
            }
        });
    </script>
</body>
</html>
