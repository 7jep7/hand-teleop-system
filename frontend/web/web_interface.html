<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"     function HandTeleopDemo() {
      const [selectedRobot, setSelectedRobot] = React.useState('so101');
      const [selectedModel, setSelectedModel] = React.useState('mediapipe');
      const [isConnected, setIsConnected] = React.useState(false);
      const [isCameraActive, setIsCameraActive] = React.useState(false);
      const [isTracking, setIsTracking] = React.useState(false);
      const [showAnalytics, setShowAnalytics] = React.useState(false);
      const [jointPositions, setJointPositions] = React.useState([0, 0, 0, 0, 0, 0]); // 6 joint positions
      const [robotInitialized, setRobotInitialized] = React.useState(false);
      const [consoleLogs, setConsoleLogs] = React.useState([]);
      const [handLandmarks, setHandLandmarks] = React.useState(null);
      const [fingertipData, setFingertipData] = React.useState({
        thumb: null,
        indexPip: null,
        indexTip: null,
        timestamp: Date.now()
      });

      // Add global error handler
      React.useEffect(() => {
        const handleError = (event) => {
          console.error('Global error caught:', event.error);
          addToConsole('Error: ' + (event.error?.message || 'Unknown error'));
        };
        
        window.addEventListener('error', handleError);
        
        return () => {
          window.removeEventListener('error', handleError);
        };
      }, []);Teleop System Demo</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  
  <!-- Three.js and MediaPipe for 3D and hand tracking -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.158.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
  <style>
    @tailwind base;
    @tailwind components;
    @tailwind utilities;
    :root {
      --background: hsl(0, 0%, 4%);
      --foreground: hsl(0, 0%, 100%);
      --muted: hsl(0, 0%, 10%);
      --muted-foreground: hsl(0, 0%, 64%);
      --popover: hsl(0, 0%, 4%);
      --popover-foreground: hsl(0, 0%, 100%);
      --card: hsl(0, 0%, 10%);
      --card-foreground: hsl(0, 0%, 100%);
      --border: hsl(0, 0%, 15%);
      --input: hsl(0, 0%, 15%);
      --primary: hsl(20, 95%, 54%);
      --primary-foreground: hsl(0, 0%, 100%);
      --secondary: hsl(0, 0%, 10%);
      --secondary-foreground: hsl(0, 0%, 100%);
      --accent: hsl(0, 0%, 10%);
      --accent-foreground: hsl(0, 0%, 100%);
      --destructive: hsl(0, 84%, 60%);
      --destructive-foreground: hsl(0, 0%, 98%);
      --ring: hsl(20, 95%, 54%);
      --radius: 0.75rem;
    }
    .dark {
      --background: hsl(0, 0%, 4%);
      --foreground: hsl(0, 0%, 100%);
      --muted: hsl(0, 0%, 10%);
      --muted-foreground: hsl(0, 0%, 64%);
      --popover: hsl(0, 0%, 4%);
      --popover-foreground: hsl(0, 0%, 100%);
      --card: hsl(0, 0%, 10%);
      --card-foreground: hsl(0, 0%, 100%);
      --border: hsl(0, 0%, 15%);
      --input: hsl(0, 0%, 15%);
      --primary: hsl(20, 95%, 54%);
      --primary-foreground: hsl(0, 0%, 100%);
      --secondary: hsl(0, 0%, 10%);
      --secondary-foreground: hsl(0, 0%, 100%);
      --accent: hsl(0, 0%, 10%);
      --accent-foreground: hsl(0, 0%, 100%);
      --destructive: hsl(0, 84%, 60%);
      --destructive-foreground: hsl(0, 0%, 98%);
      --ring: hsl(20, 95%, 54%);
    }
    @layer base {
      * { border-color: hsl(var(--border)); }
      html { scroll-behavior: smooth; }
      body {
        background-color: var(--background);
        color: var(--foreground);
        font-family: 'Inter', sans-serif;
      }
    }
    @layer utilities {
      .text-gradient {
        background: linear-gradient(135deg, hsl(20, 95%, 54%) 0%, hsl(30, 100%, 60%) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .backdrop-blur-glass {
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
      }
      
      /* Custom slider styles */
      .slider::-webkit-slider-thumb {
        appearance: none;
        height: 20px;
        width: 20px;
        border-radius: 50%;
        background: #f97316;
        cursor: pointer;
        border: 2px solid #ffffff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      
      .slider::-moz-range-thumb {
        height: 20px;
        width: 20px;
        border-radius: 50%;
        background: #f97316;
        cursor: pointer;
        border: 2px solid #ffffff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      
      .slider:focus::-webkit-slider-thumb {
        box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.3);
      }
    }
    html, body {
      background-color: #fff;
      color: #111;
    }
    @media (prefers-color-scheme: dark) {
      html, body { color-scheme: dark; }
    }
  </style>
</head>
<body class="dark">
  <div id="root"></div>
  <script type="text/babel">
    const ROBOTS = [
      { id: 'ur5e', name: 'UR5e', dof: 6 },
      { id: 'franka', name: 'Franka Emika Panda', dof: 7 },
      { id: 'kinova', name: 'Kinova Gen3', dof: 7 },
      { id: 'kuka', name: 'KUKA LBR iiwa', dof: 7 },
      { id: 'so101', name: 'SO-101 Humanoid Hand', dof: 5 },
      { id: 'simulation', name: 'Simulation Mode', dof: 6 }
    ];
    const HAND_MODELS = [
      { id: 'mediapipe', name: 'MediaPipe Hands' },
      { id: 'wilor', name: 'WiLoR' }
    ];

    const API_BASE = 'http://localhost:8000';

    function HandTeleopDemo() {
      const [selectedRobot, setSelectedRobot] = React.useState('so101');
      const [selectedModel, setSelectedModel] = React.useState('mediapipe');
      const [isConnected, setIsConnected] = React.useState(false);
      const [isCameraActive, setIsCameraActive] = React.useState(false);
      const [isTracking, setIsTracking] = React.useState(false);
      const [showAnalytics, setShowAnalytics] = React.useState(false);
      const [jointPositions, setJointPositions] = React.useState([0, 0, 0, 0, 0, 0]); // 6 joint positions
      const [robotInitialized, setRobotInitialized] = React.useState(false);
      const [consoleLogs, setConsoleLogs] = React.useState([]);
      const [handLandmarks, setHandLandmarks] = React.useState(null);
      const [fingertipData, setFingertipData] = React.useState({
        thumb: null,
        indexPip: null,
        indexTip: null,
        timestamp: 0
      });

      // Refs for camera, canvas, and 3D scene
      const videoRef = React.useRef(null);
      const canvasRef = React.useRef(null);
      const streamRef = React.useRef(null);
      const sceneRef = React.useRef(null);
      const rendererRef = React.useRef(null);
      const animationRef = React.useRef(null);
      const handsRef = React.useRef(null);

      // Helper function to log messages
      const addToConsole = (message) => {
        try {
          const timestamp = new Date().toLocaleTimeString();
          setConsoleLogs(prev => {
            const newLogs = [`[${timestamp}] ${message}`, ...prev].slice(0, 50);
            console.log(`[HandTeleop] ${message}`);
            return newLogs;
          });
        } catch (error) {
          console.error('Error in addToConsole:', error);
        }
      };

      // Initialize MediaPipe Hands
      React.useEffect(() => {
        if (typeof Hands !== 'undefined') {
          const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
          });
          
          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });

          hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
              const landmarks = results.multiHandLandmarks[0];
              setHandLandmarks(landmarks);
              
              // Extract fingertip data
              const newFingertipData = {
                thumb: landmarks[4] ? { x: landmarks[4].x * 640, y: landmarks[4].y * 480, z: landmarks[4].z } : null,
                indexPip: landmarks[6] ? { x: landmarks[6].x * 640, y: landmarks[6].y * 480, z: landmarks[6].z } : null,
                indexTip: landmarks[8] ? { x: landmarks[8].x * 640, y: landmarks[8].y * 480, z: landmarks[8].z } : null,
                timestamp: Date.now()
              };
              setFingertipData(newFingertipData);
              
              // Draw landmarks on canvas
              if (canvasRef.current) {
                const ctx = canvasRef.current.getContext('2d');
                ctx.save();
                ctx.clearRect(0, 0, 640, 480);
                
                if (landmarks) {
                  // Draw hand connections
                  ctx.strokeStyle = '#00FF00';
                  ctx.lineWidth = 3;
                  const connections = [
                    [0,1],[1,2],[2,3],[3,4], // thumb
                    [0,5],[5,6],[6,7],[7,8], // index
                    [5,9],[9,10],[10,11],[11,12], // middle
                    [9,13],[13,14],[14,15],[15,16], // ring
                    [13,17],[17,18],[18,19],[19,20], // pinky
                    [0,17] // palm
                  ];
                  
                  connections.forEach(([start, end]) => {
                    if (landmarks[start] && landmarks[end]) {
                      ctx.beginPath();
                      ctx.moveTo(landmarks[start].x * 640, landmarks[start].y * 480);
                      ctx.lineTo(landmarks[end].x * 640, landmarks[end].y * 480);
                      ctx.stroke();
                    }
                  });
                  
                  // Draw landmarks with different colors for fingertips
                  landmarks.forEach((landmark, index) => {
                    const x = landmark.x * 640;
                    const y = landmark.y * 480;
                    
                    if (index === 4) { // Thumb tip
                      ctx.fillStyle = '#FF0000';
                      ctx.strokeStyle = '#FFFFFF';
                      ctx.lineWidth = 2;
                      ctx.beginPath();
                      ctx.arc(x, y, 8, 0, 2 * Math.PI);
                      ctx.fill();
                      ctx.stroke();
                      
                      // Label
                      ctx.fillStyle = '#FFFFFF';
                      ctx.font = '12px Arial';
                      ctx.fillText('THUMB', x + 10, y - 10);
                    } else if (index === 8) { // Index tip
                      ctx.fillStyle = '#0000FF';
                      ctx.strokeStyle = '#FFFFFF';
                      ctx.lineWidth = 2;
                      ctx.beginPath();
                      ctx.arc(x, y, 8, 0, 2 * Math.PI);
                      ctx.fill();
                      ctx.stroke();
                      
                      // Label
                      ctx.fillStyle = '#FFFFFF';
                      ctx.font = '12px Arial';
                      ctx.fillText('INDEX', x + 10, y - 10);
                    } else {
                      ctx.fillStyle = '#00FF00';
                      ctx.beginPath();
                      ctx.arc(x, y, 4, 0, 2 * Math.PI);
                      ctx.fill();
                    }
                  });
                  
                  // Draw distance line between thumb and index
                  if (landmarks[4] && landmarks[8]) {
                    const thumbX = landmarks[4].x * 640;
                    const thumbY = landmarks[4].y * 480;
                    const indexX = landmarks[8].x * 640;
                    const indexY = landmarks[8].y * 480;
                    
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(thumbX, thumbY);
                    ctx.lineTo(indexX, indexY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Distance text
                    const distance = Math.sqrt(Math.pow(thumbX - indexX, 2) + Math.pow(thumbY - indexY, 2));
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = '14px Arial';
                    ctx.fillText(`Distance: ${distance.toFixed(1)}px`, 10, 30);
                  }
                }
                ctx.restore();
              }
            } else {
              setHandLandmarks(null);
              setFingertipData({
                thumb: null,
                indexPip: null,
                indexTip: null,
                timestamp: Date.now()
              });
            }
          });

          handsRef.current = hands;
        }
      }, []);

      // Initialize SO-101 robot visualization on mount
      React.useEffect(() => {
        // Use a ref instead of direct DOM manipulation
        const timer = setTimeout(() => {
          initSO101Robot();
        }, 200);
        
        return () => {
          clearTimeout(timer);
          cleanupRobot();
        };
      }, []);

      // Use a ref for the robot container instead of getElementById
      const robotContainerRef = React.useRef(null);

      const cleanupRobot = () => {
        try {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
            animationRef.current = null;
          }
          
          if (rendererRef.current) {
            rendererRef.current.dispose();
            rendererRef.current = null;
          }
          
          if (sceneRef.current) {
            sceneRef.current.clear();
            sceneRef.current = null;
          }
        } catch (error) {
          console.log('Cleanup error (safe to ignore):', error);
        }
      };

      const initSO101Robot = () => {
        if (robotInitialized) return;
        
        const robotContainer = robotContainerRef.current;
        if (!robotContainer) {
          console.log('Robot container ref not ready, retrying...');
          setTimeout(initSO101Robot, 200);
          return;
        }

        try {
          // Clear container safely using React ref
          robotContainer.innerHTML = '';

          // Create Three.js scene
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x1a1a1a);
          
          const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
          camera.position.set(0, 0, 300);
          
          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(400, 400);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          
          robotContainer.appendChild(renderer.domElement);
          
          // Add lighting
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          scene.add(ambientLight);
          
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(100, 100, 50);
          directionalLight.castShadow = true;
          scene.add(directionalLight);
          
          // Create a simple robot representation since STL loading might fail
          const robotGroup = new THREE.Group();
        
        // Base (gray box)
        const baseGeometry = new THREE.BoxGeometry(40, 10, 40);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -20;
        robotGroup.add(base);
        
        // Moving parts (orange boxes to represent gripper)
        const jaw1Geometry = new THREE.BoxGeometry(15, 30, 8);
        const jawMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 });
        const jaw1 = new THREE.Mesh(jaw1Geometry, jawMaterial);
        jaw1.position.set(-10, 0, 0);
        robotGroup.add(jaw1);
        
        const jaw2 = new THREE.Mesh(jaw1Geometry, jawMaterial);
        jaw2.position.set(10, 0, 0);
        robotGroup.add(jaw2);
        
        scene.add(robotGroup);
        
        sceneRef.current = scene;
        rendererRef.current = renderer;
        setRobotInitialized(true);
        
        addToConsole('SO-101 robot model loaded successfully');
        
        // Animation loop
        const animate = () => {
          if (sceneRef.current && rendererRef.current) {
            // Rotate robot based on hand position or joint controls
            if (fingertipData.indexTip) {
              const rotationY = (fingertipData.indexTip.x - 320) * 0.01;
              robotGroup.rotation.y = rotationY;
              
              // Move jaws based on thumb-index distance
              if (fingertipData.thumb && fingertipData.indexTip) {
                const distance = Math.sqrt(
                  Math.pow(fingertipData.thumb.x - fingertipData.indexTip.x, 2) +
                  Math.pow(fingertipData.thumb.y - fingertipData.indexTip.y, 2)
                );
                const jawOffset = Math.max(5, Math.min(15, distance / 10));
                jaw1.position.x = -jawOffset;
                jaw2.position.x = jawOffset;
                
                // Update joint positions based on hand tracking
                const newJoints = [...jointPositions];
                newJoints[0] = rotationY * 180 / Math.PI; // Base rotation in degrees
                newJoints[5] = (jawOffset - 10) * 10; // Gripper position
                setJointPositions(newJoints);
              }
            } else {
              // Use manual joint controls when no hand tracking
              robotGroup.rotation.y = jointPositions[0] * Math.PI / 180;
              const jawOffset = 10 + jointPositions[5] / 10;
              jaw1.position.x = -jawOffset;
              jaw2.position.x = jawOffset;
            }
            
            rendererRef.current.render(sceneRef.current, camera);
            animationRef.current = requestAnimationFrame(animate);
          }
        };
        animate();
        
        } catch (error) {
          console.error('Error initializing robot:', error);
          addToConsole('Failed to initialize robot visualization: ' + error.message);
          setRobotInitialized(false);
        }
      };

      // Handle manual joint position changes
      const updateJointPosition = (jointIndex, value) => {
        const newJoints = [...jointPositions];
        newJoints[jointIndex] = parseFloat(value);
        setJointPositions(newJoints);
      };

      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: 640, height: 480, facingMode: 'user' } 
          });
          streamRef.current = stream;
          
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.onloadedmetadata = () => {
              videoRef.current.play();
              setIsCameraActive(true);
              addToConsole('Camera started successfully');
              
              // Start hand tracking
              if (handsRef.current) {
                const processFrame = async () => {
                  if (videoRef.current && isCameraActive) {
                    await handsRef.current.send({ image: videoRef.current });
                    setTimeout(processFrame, 33); // ~30fps
                  }
                };
                processFrame();
              }
            };
          }
        } catch (error) {
          console.error("Camera access denied:", error);
          addToConsole('Camera access denied');
          alert("Camera access is required for hand tracking");
        }
      };

      const stopCamera = () => {
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
        if (videoRef.current) {
          videoRef.current.srcObject = null;
        }
        setIsCameraActive(false);
        setIsTracking(false);
        addToConsole('Camera stopped');
        
        // Clear canvas
        if (canvasRef.current) {
          const ctx = canvasRef.current.getContext('2d');
          ctx.clearRect(0, 0, 640, 480);
        }
      };

      const connectToRobot = () => {
        try {
          addToConsole(`Connecting to robot: ${selectedRobot}`);
          setIsConnected(true);
          addToConsole('Robot connected successfully');
        } catch (error) {
          console.error('Connection error:', error);
          addToConsole('Connection error: ' + error.message);
        }
      };

      return (
        <div className="min-h-screen bg-gray-900 text-white">
          <header className="fixed top-0 left-0 right-0 z-50 border-b bg-gray-800/70 backdrop-blur-glass border-gray-700/50">
            <div className="max-w-4xl mx-auto px-6 py-4 flex justify-between items-center">
              <div className="flex items-center space-x-2">
                <div className="w-10 h-10 rounded-full bg-orange-500 flex items-center justify-center hover:bg-orange-600 transition-colors">
                  <span className="text-white font-bold text-lg">JP</span>
                </div>
              </div>
              <div className="flex items-center space-x-6">
                <a href="/" className="flex items-center space-x-2 text-sm font-medium text-gray-300 hover:text-orange-500 transition-colors">
                  <span>&larr;</span>
                  <span>Back to Home</span>
                </a>
              </div>
            </div>
          </header>
          <div className="pt-20 px-6 max-w-6xl mx-auto">
            <div className="text-center mb-12">
              <h1 className="text-4xl font-bold mb-4 text-white">Hand Teleop System</h1>
              <p className="text-xl text-gray-300 max-w-2xl mx-auto">Control robots with natural hand movements</p>
            </div>
            <div className="grid lg:grid-cols-2 gap-6 mb-8">
              <div className="bg-gray-800 border-gray-700 p-6 rounded-xl">
                <div className="flex items-center gap-2 mb-6">
                  <span className="inline-block"><svg className="h-5 w-5 text-primary" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><rect x="2" y="7" width="20" height="15" rx="2"/><path d="M2 7V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v2"/></svg></span>
                  <h2 className="text-xl font-semibold text-white">Robot</h2>
                  <span className={`ml-auto px-2 py-1 rounded text-xs ${isConnected ? 'bg-green-500' : 'bg-gray-600'}`}>{isConnected ? 'Connected' : 'Disconnected'}</span>
                </div>
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium mb-2 text-white">Robot Embodiment</label>
                    <select value={selectedRobot} onChange={e => setSelectedRobot(e.target.value)} className="w-full p-3 bg-gray-800 border border-gray-600 rounded-lg text-white">
                      {ROBOTS.map(robot => (
                        <option key={robot.id} value={robot.id} className="bg-gray-800 text-white">{robot.name} ({robot.dof} DOF)</option>
                      ))}
                    </select>
                  </div>
                  <div ref={robotContainerRef} className="aspect-square bg-gray-900 rounded-lg border-2 border-dashed border-gray-600 relative overflow-hidden flex items-center justify-center">
                    {!robotInitialized && <span className="text-gray-400">Initializing robot visualization...</span>}
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    <button 
                      className={`px-4 py-2 rounded ${isConnected ? 'bg-gray-700' : 'bg-orange-500'} text-white`} 
                      onClick={connectToRobot} 
                      disabled={isConnected}
                    >
                      {isConnected ? 'Connected' : 'Connect'}
                    </button>
                    <button 
                      className={`px-4 py-2 rounded ${isTracking ? 'bg-gray-700' : 'bg-orange-500'} text-white`} 
                      onClick={() => setIsTracking(!isTracking)} 
                      disabled={!isConnected || !isCameraActive}
                    >
                      {isTracking ? 'Stop Control' : 'Start Control'}
                    </button>
                  </div>
                </div>
              </div>
              <div className="bg-gray-800 border-gray-700 p-6 rounded-xl">
                <div className="flex items-center gap-2 mb-6">
                  <span className="inline-block"><svg className="h-5 w-5 text-primary" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><rect x="9" y="9" width="6" height="6"/></svg></span>
                  <h2 className="text-xl font-semibold text-white">Camera Feed</h2>
                  <span className={`ml-auto px-2 py-1 rounded text-xs ${isCameraActive ? 'bg-green-500' : 'bg-gray-600'}`}>{isCameraActive ? 'Active' : 'Inactive'}</span>
                </div>
                <div className="space-y-4">
                  <div className="flex gap-2">
                    <button 
                      className={`flex-1 px-4 py-2 rounded ${isCameraActive ? 'bg-gray-700' : 'bg-orange-500'} text-white`} 
                      onClick={startCamera} 
                      disabled={isCameraActive}
                    >
                      {isCameraActive ? 'Camera Active' : 'Start Camera'}
                    </button>
                    <button 
                      className="flex-1 px-4 py-2 rounded bg-gray-700 text-white" 
                      onClick={stopCamera} 
                      disabled={!isCameraActive}
                    >
                      Stop
                    </button>
                  </div>
                  <div className="bg-gray-900 rounded-lg overflow-hidden aspect-video relative">
                    <video
                      ref={videoRef}
                      autoPlay
                      playsInline
                      muted
                      className="w-full h-full object-cover"
                      style={{ display: isCameraActive ? 'block' : 'none' }}
                    />
                    <canvas
                      ref={canvasRef}
                      width="640"
                      height="480"
                      className="absolute top-0 left-0 w-full h-full"
                      style={{ display: isCameraActive ? 'block' : 'none' }}
                    />
                    {!isCameraActive && (
                      <div className="w-full h-full flex items-center justify-center text-gray-400">
                        <div className="text-center">
                          <span className="text-gray-400">Camera feed will appear here</span>
                          <p className="text-sm text-gray-400 mt-2">Grant camera access to start tracking</p>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
            <div className="bg-gray-800 border-gray-700 rounded-xl overflow-hidden mt-8">
              <button onClick={() => setShowAnalytics(!showAnalytics)} className="w-full p-6 text-left flex items-center justify-between hover:bg-gray-700/50 transition-colors">
                <div className="flex items-center gap-2">
                  <span className="inline-block"><svg className="h-5 w-5 text-primary" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg></span>
                  <h2 className="text-xl font-semibold text-white">Analytics & Debug Info</h2>
                </div>
                <span>{showAnalytics ? '▲' : '▼'}</span>
              </button>
              {showAnalytics && (
                <div className="px-6 pb-6 border-t border-gray-700">
                  <div className="grid md:grid-cols-2 gap-6 mt-6">
                    <div>
                      <label className="block text-sm font-medium mb-2 text-white">Hand Tracking Model</label>
                      <select value={selectedModel} onChange={e => setSelectedModel(e.target.value)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-white">
                        {HAND_MODELS.map(model => (
                          <option key={model.id} value={model.id} className="bg-gray-800 text-white">{model.name}</option>
                        ))}
                      </select>
                    </div>
                    <div>
                      <h3 className="font-medium mb-2 flex items-center gap-2 text-white">Hand Tracking</h3>
                      <div className="text-xs font-mono text-gray-300 space-y-1">
                        {fingertipData.thumb && fingertipData.indexTip ? (
                          <>
                            <div>Thumb: ({fingertipData.thumb.x.toFixed(1)}, {fingertipData.thumb.y.toFixed(1)}, {fingertipData.thumb.z.toFixed(3)})</div>
                            <div>Index: ({fingertipData.indexTip.x.toFixed(1)}, {fingertipData.indexTip.y.toFixed(1)}, {fingertipData.indexTip.z.toFixed(3)})</div>
                            <div>Updated: {new Date(fingertipData.timestamp).toLocaleTimeString()}</div>
                          </>
                        ) : (
                          <div>No hand detected</div>
                        )}
                      </div>
                    </div>
                    <div className="md:col-span-2">
                      <h3 className="font-medium mb-4 flex items-center gap-2 text-white">Robot Joint Control</h3>
                      <div className="grid grid-cols-2 gap-4">
                        {jointPositions.map((position, index) => (
                          <div key={index} className="space-y-2">
                            <label className="block text-sm font-medium text-gray-300">
                              Joint {index + 1}: {position.toFixed(2)}°
                            </label>
                            <input
                              type="range"
                              min={index === 5 ? "-50" : "-180"}
                              max={index === 5 ? "50" : "180"}
                              step="0.1"
                              value={position}
                              onChange={(e) => updateJointPosition(index, e.target.value)}
                              className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                              style={{
                                background: `linear-gradient(to right, #f97316 0%, #f97316 ${((position - (index === 5 ? -50 : -180)) / (index === 5 ? 100 : 360)) * 100}%, #374151 ${((position - (index === 5 ? -50 : -180)) / (index === 5 ? 100 : 360)) * 100}%, #374151 100%)`
                              }}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                              <span>{index === 5 ? "-50°" : "-180°"}</span>
                              <span>{index === 5 ? "+50°" : "+180°"}</span>
                            </div>
                          </div>
                        ))}
                      </div>
                      <div className="mt-4 p-3 bg-gray-800 rounded-lg">
                        <div className="text-xs font-mono text-gray-300 space-y-1">
                          <div className="text-sm font-medium text-white mb-2">Current Joint States:</div>
                          {jointPositions.map((position, index) => (
                            <div key={index}>J{index + 1}: {position.toFixed(3)}° ({(position * Math.PI / 180).toFixed(3)} rad)</div>
                          ))}
                        </div>
                      </div>
                    </div>
                    <div>
                      <h3 className="font-medium mb-2 flex items-center gap-2 text-white">API Status</h3>
                      <div className="text-sm font-medium mb-2 text-yellow-400">⏳ Checking...</div>
                      <button 
                        className="px-3 py-1 rounded border border-gray-600 text-gray-300 hover:border-orange-500 hover:text-orange-500"
                        onClick={() => window.open(`${API_BASE}/docs`, '_blank')}
                      >
                        API Docs
                      </button>
                    </div>
                  </div>
                  <div className="mt-6">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="font-medium flex items-center gap-2 text-white">Output Console</h3>
                      <button className="px-2 py-1 rounded border border-gray-600 text-gray-300 hover:border-orange-500 hover:text-orange-500" onClick={() => setConsoleLogs([])}>Clear</button>
                    </div>
                    <div className="bg-gray-900 border border-gray-600 rounded-lg p-3 h-32 overflow-y-auto">
                      <div className="text-gray-400 text-xs">Console output will appear here...</div>
                    </div>
                  </div>
                </div>
              )}
            </div>
            <div className="mt-8 text-center">
              <div className="flex flex-wrap justify-center gap-4">
                <a href="#" className="px-4 py-2 rounded border border-gray-600 text-gray-300 hover:border-orange-500 hover:text-orange-500">Full Demo</a>
                <a href="https://github.com/7jep7/human2robot" className="px-4 py-2 rounded border border-gray-600 text-gray-300 hover:border-orange-500 hover:text-orange-500">GitHub</a>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Error boundary component
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error: error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('React Error:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
              <div className="text-center">
                <h1 className="text-2xl font-bold mb-4">Something went wrong</h1>
                <p className="text-gray-400 mb-4">Error: {this.state.error?.message}</p>
                <button 
                  onClick={() => window.location.reload()} 
                  className="px-4 py-2 bg-orange-500 text-white rounded hover:bg-orange-600"
                >
                  Reload Page
                </button>
              </div>
            </div>
          );
        }

        return this.props.children;
      }
    }

    ReactDOM.render(
      <ErrorBoundary>
        <HandTeleopDemo />
      </ErrorBoundary>, 
      document.getElementById('root')
    );
  </script>
</body>
</html>
