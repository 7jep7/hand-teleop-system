<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SO-101 Robot Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js and Robot Rendering Libraries -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/urdf-loader@0.12.6/build/urdf-loader.js"></script>
    
    <!-- STLLoader for loading real mesh files -->
    <script>
        // STLLoader class (inlined to avoid CDN issues)
        class STLLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(scope.manager);
                loader.setPath(scope.path);
                loader.setResponseType('arraybuffer');
                loader.setRequestHeader(scope.requestHeader);
                loader.setWithCredentials(scope.withCredentials);
                loader.load(url, function (text) {
                    try {
                        onLoad(scope.parse(text));
                    } catch (e) {
                        if (onError) {
                            onError(e);
                        } else {
                            console.error(e);
                        }
                        scope.manager.itemError(url);
                    }
                }, onProgress, onError);
            }

            parse(data) {
                function isBinary(data) {
                    const reader = new DataView(data);
                    const face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);
                    const n_faces = reader.getUint32(80, true);
                    const expect = 80 + (32 / 8) + (n_faces * face_size);
                    if (expect === reader.byteLength) {
                        return true;
                    }
                    const fileLength = reader.byteLength;
                    for (let index = 0; index < fileLength; index++) {
                        if (reader.getUint8(index, false) > 127) {
                            return true;
                        }
                    }
                    return false;
                }

                function parseBinary(data) {
                    const reader = new DataView(data);
                    const faces = reader.getUint32(80, true);
                    let r, g, b, hasColors = false, colors;
                    let defaultR, defaultG, defaultB, alpha;

                    for (let index = 0; index < 80 - 10; index++) {
                        if ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&
                            (reader.getUint8(index + 4) == 0x52 /*'R'*/) &&
                            (reader.getUint8(index + 5) == 0x3D /*'='*/)) {
                            hasColors = true;
                            colors = [];
                            defaultR = reader.getUint8(index + 6) / 255;
                            defaultG = reader.getUint8(index + 7) / 255;
                            defaultB = reader.getUint8(index + 8) / 255;
                            alpha = reader.getUint8(index + 9) / 255;
                        }
                    }

                    const dataOffset = 84;
                    const faceLength = 12 * 4 + 2;
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const normals = [];

                    for (let face = 0; face < faces; face++) {
                        const start = dataOffset + face * faceLength;
                        const normalX = reader.getFloat32(start, true);
                        const normalY = reader.getFloat32(start + 4, true);
                        const normalZ = reader.getFloat32(start + 8, true);

                        if (hasColors) {
                            const packedColor = reader.getUint16(start + 48, true);
                            if ((packedColor & 0x8000) === 0) {
                                r = (packedColor & 0x1F) / 31;
                                g = ((packedColor >> 5) & 0x1F) / 31;
                                b = ((packedColor >> 10) & 0x1F) / 31;
                            } else {
                                r = defaultR;
                                g = defaultG;
                                b = defaultB;
                            }
                        }

                        for (let i = 1; i <= 3; i++) {
                            const vertexstart = start + i * 12;
                            const componentIdx = (face * 3 * 3) + ((i - 1) * 3);
                            vertices[componentIdx] = reader.getFloat32(vertexstart, true);
                            vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);
                            vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);
                            normals[componentIdx] = normalX;
                            normals[componentIdx + 1] = normalY;
                            normals[componentIdx + 2] = normalZ;

                            if (hasColors) {
                                colors[(face * 3 * 3) + ((i - 1) * 3)] = r;
                                colors[(face * 3 * 3) + ((i - 1) * 3) + 1] = g;
                                colors[(face * 3 * 3) + ((i - 1) * 3) + 2] = b;
                            }
                        }
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

                    if (hasColors) {
                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        geometry.hasColors = true;
                        geometry.alpha = alpha;
                    }

                    return geometry;
                }

                function parseASCII(data) {
                    const geometry = new THREE.BufferGeometry();
                    const patternSolid = /solid([\s\S]*?)endsolid/g;
                    const patternFace = /facet[\s]+normal[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+outer[\s]+loop([\s\S]*?)endloop[\s]+endfacet/g;
                    const patternFloat = /[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/g;

                    const vertices = [];
                    const normals = [];

                    const normal = new THREE.Vector3();

                    let result;

                    while ((result = patternSolid.exec(data)) !== null) {
                        const solid = result[0];

                        while ((result = patternFace.exec(solid)) !== null) {
                            let vertexCountPerFace = 0;
                            let normalCountPerFace = 0;

                            const text = result[0];

                            while ((result = patternFloat.exec(text)) !== null) {
                                if (normalCountPerFace < 3) {
                                    normal.x = parseFloat(result[1]);
                                    normal.y = parseFloat(result[3]);
                                    normal.z = parseFloat(result[5]);
                                    normalCountPerFace++;
                                } else {
                                    vertices.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));
                                    normals.push(normal.x, normal.y, normal.z);
                                    vertexCountPerFace++;

                                    if (vertexCountPerFace % 3 === 0) {
                                        patternFloat.lastIndex = 0;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

                    return geometry;
                }

                if (data instanceof ArrayBuffer) {
                    return isBinary(data) ? parseBinary(data) : parseASCII(new TextDecoder().decode(data));
                } else {
                    return parseASCII(data);
                }
            }
        }
    </script>
    
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
        #canvas-container { 
            position: relative; 
            width: 100vw; 
            height: 70vh; 
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 100%);
        }
        #controls { 
            background: rgba(15, 23, 42, 0.95); 
            backdrop-filter: blur(10px);
        }
        .joint-slider {
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #334155;
            outline: none;
        }
        .joint-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-connected { background-color: #22c55e; }
        .status-disconnected { background-color: #ef4444; }
        .status-loading { background-color: #f59e0b; animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white">
    <!-- Header -->
    <div class="bg-slate-800 border-b border-slate-700 px-6 py-4">
        <div class="flex items-center justify-between">
            <div>
                <h1 class="text-2xl font-bold text-white">SO-101 Robot Simulation</h1>
                <p class="text-slate-400">Real-time robot control and visualization</p>
            </div>
            <div class="flex items-center space-x-4">
                <div class="flex items-center">
                    <span id="connection-status" class="status-dot status-loading"></span>
                    <span id="connection-text" class="text-sm">Connecting...</span>
                </div>
                <div class="text-sm">
                    <div>FPS: <span id="fps-display" class="font-mono">0</span></div>
                    <div>Latency: <span id="latency-display" class="font-mono">0ms</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="flex h-screen">
        <!-- 3D Viewport -->
        <div id="canvas-container" class="flex-1">
            <canvas id="robot-canvas" class="w-full h-full"></canvas>
            
            <!-- Loading Overlay -->
            <div id="loading-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
                <div class="text-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
                    <p class="text-lg">Loading SO-101 Robot...</p>
                    <p id="loading-status" class="text-sm text-slate-400">Initializing...</p>
                </div>
            </div>
        </div>

        <!-- Control Panel -->
        <div id="controls" class="w-80 p-6 overflow-y-auto">
            <h3 class="text-lg font-semibold mb-4">Joint Controls</h3>
            
            <!-- Joint Sliders -->
            <div id="joint-controls" class="space-y-4">
                <!-- Will be populated by JavaScript -->
            </div>
            
            <hr class="border-slate-600 my-6">
            
            <!-- Robot Info -->
            <h3 class="text-lg font-semibold mb-4">Robot Information</h3>
            <div id="robot-info" class="space-y-2 text-sm">
                <div>Model: <span class="text-blue-400">SO-101</span></div>
                <div>DOF: <span id="dof-display" class="text-blue-400">6</span></div>
                <div>Status: <span id="robot-status" class="text-green-400">Ready</span></div>
            </div>
            
            <hr class="border-slate-600 my-6">
            
            <!-- Demo Controls -->
            <h3 class="text-lg font-semibold mb-4">Demo Controls</h3>
            <div class="space-y-3">
                <button id="home-position" class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded transition">
                    Home Position
                </button>
                <button id="demo-motion" class="w-full bg-green-600 hover:bg-green-700 px-4 py-2 rounded transition">
                    Demo Motion
                </button>
                <button id="random-motion" class="w-full bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded transition">
                    Random Motion
                </button>
                <button id="reset-robot" class="w-full bg-red-600 hover:bg-red-700 px-4 py-2 rounded transition">
                    Reset Robot
                </button>
            </div>
            
            <hr class="border-slate-600 my-6">
            
            <!-- Debug Info -->
            <h3 class="text-lg font-semibold mb-4">Debug Info</h3>
            <div id="debug-info" class="text-xs space-y-1 font-mono text-slate-400">
                <div>Messages: <span id="msg-count">0</span></div>
                <div>Last Update: <span id="last-update">Never</span></div>
                <div>WebSocket: <span id="ws-status">Disconnected</span></div>
            </div>
        </div>
    </div>

    <script>
        // SO-101 Robot Simulation Controller
        class SO101Simulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.robot = null;
                this.websocket = null;
                this.animationId = null;
                
                // Joint state
                this.jointNames = ["base_link", "shoulder_pan", "shoulder_lift", "elbow_flex", "wrist_flex", "gripper"];
                this.jointPositions = new Array(6).fill(0);  // 6 DOF
                this.targetPositions = new Array(6).fill(0);
                
                // Performance tracking
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.lastPingTime = 0;
                this.latency = 0;
                this.messageCount = 0;
                
                this.init();
            }
            
            async init() {
                this.updateLoadingStatus("Initializing 3D scene...");
                await this.initThreeJS();
                
                this.updateLoadingStatus("Loading robot model...");
                await this.loadRobot();
                
                this.updateLoadingStatus("Connecting to robot simulation...");
                await this.connectWebSocket();
                
                this.updateLoadingStatus("Setting up controls...");
                this.setupControls();
                
                this.updateLoadingStatus("Starting animation...");
                this.startAnimation();
                
                // Hide loading overlay
                document.getElementById('loading-overlay').style.display = 'none';
                
                console.log("✅ SO-101 Simulation initialized successfully");
            }
            
            updateLoadingStatus(status) {
                document.getElementById('loading-status').textContent = status;
            }
            
            async initThreeJS() {
                const canvas = document.getElementById('robot-canvas');
                const container = document.getElementById('canvas-container');
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1e293b);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    container.clientWidth / container.clientHeight, 
                    0.01, 
                    1000
                );
                this.camera.position.set(1.2, 1.2, 1.2);  // Good balanced view - not too far, not too close
                this.camera.lookAt(0, 0, 0.2);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true, 
                    alpha: true 
                });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(2, 2);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Camera controls (simple mouse controls)
                this.setupCameraControls(canvas);
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupCameraControls(canvas) {
                let isMouseDown = false;
                let mouseX = 0, mouseY = 0;
                let cameraRadius = 15;  // Start much further out
                let cameraTheta = Math.PI / 4;
                let cameraPhi = Math.PI / 4;
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;
                        
                        cameraTheta += deltaX * 0.01;
                        cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + deltaY * 0.01));
                        
                        this.updateCameraPosition(cameraRadius, cameraTheta, cameraPhi);
                        
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    cameraRadius = Math.max(0.1, cameraRadius + e.deltaY * 0.01);  // No upper limit, faster zoom
                    this.updateCameraPosition(cameraRadius, cameraTheta, cameraPhi);
                    e.preventDefault();
                });
                
                this.updateCameraPosition(cameraRadius, cameraTheta, cameraPhi);
            }
            
            updateCameraPosition(radius, theta, phi) {
                this.camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                this.camera.position.y = radius * Math.cos(phi);
                this.camera.position.z = radius * Math.sin(phi) * Math.sin(theta) + 0.2;
                this.camera.lookAt(0, 0, 0.2);
            }
            
            async loadRobot() {
                try {
                    console.log("🔄 Loading SO-101 robot with real STL meshes...");
                    
                    // Create the robot group
                    this.robot = new THREE.Group();
                    this.robot.name = 'so101_real';
                    
                    // Add debugging info
                    console.log("Scene before loading robot:", this.scene.children.length, "children");
                    
                    // Define the STL files with better spacing for proper robotic arm structure
                    // Using distinct colors for easy debugging and feedback
                    const robotParts = [
                        { 
                            file: 'Base_SO101.stl', 
                            color: 0x8B4513,  // Brown - base/foundation
                            position: [0, 0, 0],  // Base link at origin
                            rotation: [0, 0, 0],  // Simplified rotation for now
                            scale: 0.001,  // Scale down from mm to m
                            joint: 'base_link',
                            parent: null
                        },
                        { 
                            file: 'sts3215_03a_v1.stl', 
                            color: 0xFF0000,  // Red - first motor (shoulder pan)
                            position: [0, 0, 0.08],  // 8cm above base
                            rotation: [0, 0, 0],  // Simplified
                            scale: 0.001,  // Scale down
                            joint: 'shoulder_pan',
                            parent: 0  // Attached to base
                        },
                        { 
                            file: 'Upper_arm_SO101.stl', 
                            color: 0x00FF00,  // Green - upper arm (shoulder lift)
                            position: [0, 0, 0.06],  // 6cm above motor
                            rotation: [0, 0, 0],  // Simplified
                            scale: 0.001,  // Scale down
                            joint: 'shoulder_lift',
                            parent: 1  // Attached to shoulder_pan
                        },
                        { 
                            file: 'Under_arm_SO101.stl', 
                            color: 0x0000FF,  // Blue - lower arm (elbow flex)
                            position: [0, 0.15, 0],  // 15cm forward from upper arm
                            rotation: [0, 0, 0],  // Simplified
                            scale: 0.001,  // Scale down
                            joint: 'elbow_flex',
                            parent: 2  // Attached to upper arm
                        },
                        { 
                            file: 'Wrist_Roll_SO101.stl', 
                            color: 0xFFFF00,  // Yellow - wrist (wrist flex)
                            position: [0, 0.12, 0],  // 12cm forward from lower arm
                            rotation: [0, 0, 0],  // Simplified
                            scale: 0.001,  // Scale down
                            joint: 'wrist_flex',
                            parent: 3  // Attached to lower arm
                        },
                        { 
                            file: 'Moving_Jaw_SO101.stl', 
                            color: 0xFF00FF,  // Magenta - gripper (final joint)
                            position: [0, 0.08, 0],  // 8cm forward from wrist
                            rotation: [0, 0, 0],  // Simplified
                            scale: 0.001,  // Scale down
                            joint: 'gripper',
                            parent: 4  // Attached to wrist
                        },
                    ];
                    
                    // Load STL files and create proper kinematic chain
                    const stlLoader = new STLLoader();
                    this.robotMeshes = [];
                    this.jointObjects = [];
                    
                    // First pass: create all joint groups
                    for (let i = 0; i < robotParts.length; i++) {
                        const jointGroup = new THREE.Group();
                        jointGroup.name = robotParts[i].joint;
                        jointGroup.userData = { 
                            jointIndex: i, 
                            originalPosition: [...robotParts[i].position],
                            partInfo: robotParts[i]
                        };
                        this.jointObjects.push(jointGroup);
                    }
                    
                    // Second pass: load meshes and build hierarchy
                    for (let i = 0; i < robotParts.length; i++) {
                        const part = robotParts[i];
                        try {
                            console.log(`Loading ${part.file}...`);
                            const geometry = await this.loadSTLFile(stlLoader, part.file);
                            
                            // Create material
                            const material = new THREE.MeshLambertMaterial({ 
                                color: part.color,
                                side: THREE.DoubleSide
                            });
                            
                            // Create mesh
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            mesh.name = part.file;
                            
                            // Apply scale (STL files might be in mm, we need m)
                            mesh.scale.set(part.scale, part.scale, part.scale);
                            
                            // Apply the specified rotation to the mesh
                            mesh.rotation.set(...part.rotation);
                            
                            // Position mesh at origin of its joint (important for rotation)
                            mesh.position.set(0, 0, 0);
                            
                            // Add mesh to its joint group
                            const jointGroup = this.jointObjects[i];
                            jointGroup.add(mesh);
                            
                            // Set up hierarchy: child joints attach to parent joints
                            if (part.parent !== null && part.parent < i) {
                                // This joint is a child of a previous joint
                                const parentJoint = this.jointObjects[part.parent];
                                parentJoint.add(jointGroup);
                                // Position relative to parent (this creates the kinematic chain)
                                jointGroup.position.set(...part.position);
                                console.log(`${part.joint} positioned at [${part.position}] relative to ${robotParts[part.parent].joint}`);
                            } else {
                                // This is a root joint (base)
                                this.robot.add(jointGroup);
                                jointGroup.position.set(...part.position);
                                console.log(`${part.joint} positioned at [${part.position}] in world coordinates`);
                            }
                            
                            this.robotMeshes.push(mesh);
                            
                            console.log(`✅ ${part.file} loaded and connected to hierarchy`);
                            
                        } catch (error) {
                            console.error(`❌ Failed to load ${part.file}:`, error);
                        }
                    }
                    
                    this.scene.add(this.robot);
                    console.log("✅ SO-101 robot loaded with proper kinematic chain and positioning!");
                    console.log("Robot group children:", this.robot.children.length);
                    console.log("Scene after loading robot:", this.scene.children.length, "children");
                    console.log("Robot bounding box:");
                    
                    // Calculate and log bounding box
                    const box = new THREE.Box3().setFromObject(this.robot);
                    console.log("Min:", box.min);
                    console.log("Max:", box.max);
                    console.log("Size:", box.getSize(new THREE.Vector3()));
                    
                    // If robot is too small or too far, adjust camera
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const distance = maxDim * 2;
                        this.camera.position.set(distance, distance, distance);
                        this.camera.lookAt(box.getCenter(new THREE.Vector3()));
                        console.log("Adjusted camera position to:", this.camera.position);
                    }
                    
                } catch (error) {
                    console.error("Error loading robot with STL meshes:", error);
                    console.log("🔄 Falling back to placeholder robot...");
                    await this.createPlaceholderRobot();
                }
            }
            
            async createPlaceholderRobot() {
                console.log("Creating placeholder robot with colored cubes...");
                
                // Create the robot group
                this.robot = new THREE.Group();
                this.robot.name = 'so101_placeholder';
                
                // Create simple colored cubes for visualization - better spaced structure
                // Using distinct colors for easy debugging
                const robotParts = [
                    { name: 'base_link', color: 0x8B4513, position: [0, 0, 0], size: [0.08, 0.08, 0.03] },           // Brown
                    { name: 'shoulder_pan', color: 0xFF0000, position: [0, 0, 0.08], size: [0.05, 0.05, 0.08] },    // Red
                    { name: 'shoulder_lift', color: 0x00FF00, position: [0, 0, 0.06], size: [0.06, 0.06, 0.10] },   // Green
                    { name: 'elbow_flex', color: 0x0000FF, position: [0, 0.15, 0], size: [0.05, 0.08, 0.05] },      // Blue
                    { name: 'wrist_flex', color: 0xFFFF00, position: [0, 0.12, 0], size: [0.04, 0.06, 0.04] },      // Yellow
                    { name: 'gripper', color: 0xFF00FF, position: [0, 0.08, 0], size: [0.03, 0.05, 0.03] }          // Magenta
                ];
                
                this.robotMeshes = [];
                this.jointObjects = [];
                
                // Create joint groups first
                for (let i = 0; i < robotParts.length; i++) {
                    const jointGroup = new THREE.Group();
                    jointGroup.name = robotParts[i].name;
                    jointGroup.userData = { jointIndex: i };
                    this.jointObjects.push(jointGroup);
                }
                
                // Create meshes and build hierarchy
                for (let i = 0; i < robotParts.length; i++) {
                    const part = robotParts[i];
                    
                    // Create cube geometry
                    const geometry = new THREE.BoxGeometry(...part.size);
                    const material = new THREE.MeshLambertMaterial({ color: part.color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.name = part.name;
                    
                    // Add to joint group
                    const jointGroup = this.jointObjects[i];
                    jointGroup.add(mesh);
                    
                    // Build hierarchy
                    if (i > 0) {
                        // Child of previous joint
                        const parentJoint = this.jointObjects[i - 1];
                        parentJoint.add(jointGroup);
                        jointGroup.position.set(...part.position);
                    } else {
                        // Root joint
                        this.robot.add(jointGroup);
                        jointGroup.position.set(...part.position);
                    }
                    
                    this.robotMeshes.push(mesh);
                    console.log(`Created placeholder part: ${part.name}`);
                }
                
                this.scene.add(this.robot);
                console.log("✅ Placeholder robot created!");
                
                // Position camera to see the robot at good distance
                this.camera.position.set(1.2, 1.2, 1.2);
                this.camera.lookAt(0, 0, 0.2);
            }
            
            loadSTLFile(loader, filename) {
                return new Promise((resolve, reject) => {
                    const url = `/api/assets/robot/so101/${filename}`;
                    console.log(`🔄 Loading STL: ${url}`);
                    
                    loader.load(
                        url,
                        (geometry) => {
                            console.log(`✅ Loaded ${filename}:`, geometry);
                            console.log(`   Vertices: ${geometry.attributes.position.count}`);
                            
                            // Compute bounding box for debugging
                            geometry.computeBoundingBox();
                            const box = geometry.boundingBox;
                            console.log(`   Bounding box: min=${box.min.x.toFixed(3)},${box.min.y.toFixed(3)},${box.min.z.toFixed(3)} max=${box.max.x.toFixed(3)},${box.max.y.toFixed(3)},${box.max.z.toFixed(3)}`);
                            
                            resolve(geometry);
                        },
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percentComplete = progress.loaded / progress.total * 100;
                                console.log(`Loading ${filename}: ${percentComplete.toFixed(1)}%`);
                            }
                        },
                        (error) => {
                            console.error(`❌ Failed to load ${filename}:`, error);
                            reject(error);
                        }
                    );
                });
            }
            
            async createPlaceholderRobot() {
                // Create a simple robot representation
                this.robot = new THREE.Group();
                this.robot.name = 'so101_placeholder';
                
                // Base
                const baseGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.025;
                base.castShadow = true;
                this.robot.add(base);
                
                // Create joint visualization
                this.jointObjects = [];
                const jointPositions = [
                    [0, 0.05, 0], // shoulder_pan
                    [0, 0.1, 0],  // shoulder_lift
                    [0, 0.2, 0],  // elbow_flex
                    [0, 0.3, 0],  // wrist_flex
                    [0, 0.4, 0],  // wrist_roll
                    [0, 0.45, 0]  // gripper
                ];
                
                for (let i = 0; i < 6; i++) {
                    const jointGroup = new THREE.Group();
                    
                    // Joint visualization
                    const jointGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.03);
                    const jointMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const joint = new THREE.Mesh(jointGeometry, jointMaterial);
                    joint.position.set(...jointPositions[i]);
                    
                    // Link visualization
                    if (i < 5) {
                        const linkGeometry = new THREE.BoxGeometry(0.03, 0.08, 0.03);
                        const linkMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                        const link = new THREE.Mesh(linkGeometry, linkMaterial);
                        link.position.set(0, jointPositions[i][1] + 0.04, 0);
                        jointGroup.add(link);
                    }
                    
                    jointGroup.add(joint);
                    this.robot.add(jointGroup);
                    this.jointObjects.push(jointGroup);
                }
                
                this.scene.add(this.robot);
                console.log("✅ Placeholder robot created");
            }
            
            async connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/robot/so101/simulation`;
                
                try {
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log("✅ WebSocket connected");
                        this.updateConnectionStatus(true);
                        
                        // Request robot info
                        this.sendMessage({
                            type: "get_info"
                        });
                        
                        // Start ping for latency measurement
                        this.startPingLoop();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        this.handleWebSocketMessage(JSON.parse(event.data));
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error("WebSocket error:", error);
                        this.updateConnectionStatus(false);
                    };
                    
                    this.websocket.onclose = () => {
                        console.log("WebSocket disconnected");
                        this.updateConnectionStatus(false);
                        
                        // Attempt to reconnect after 3 seconds
                        setTimeout(() => this.connectWebSocket(), 3000);
                    };
                    
                } catch (error) {
                    console.error("WebSocket connection failed:", error);
                    this.updateConnectionStatus(false);
                }
            }
            
            sendMessage(message) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                }
            }
            
            handleWebSocketMessage(message) {
                this.messageCount++;
                document.getElementById('msg-count').textContent = this.messageCount;
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                
                switch (message.type) {
                    case 'robot_state':
                        this.updateRobotState(message.data);
                        break;
                    case 'robot_info':
                        this.updateRobotInfo(message.data);
                        break;
                    case 'pong':
                        this.latency = performance.now() - this.lastPingTime;
                        document.getElementById('latency-display').textContent = Math.round(this.latency) + 'ms';
                        break;
                    case 'joint_response':
                        console.log("Joint response:", message);
                        break;
                    case 'error':
                        console.error("Server error:", message.message);
                        break;
                }
            }
            
            updateRobotState(state) {
                if (state.positions) {
                    this.jointPositions = state.positions;
                    this.updateRobotVisualization();
                }
            }
            
            updateRobotInfo(info) {
                document.getElementById('dof-display').textContent = info.dof || 6;
                console.log("Robot info:", info);
            }
            
            updateRobotVisualization() {
                if (!this.robot || !this.jointObjects || this.jointObjects.length === 0) return;
                
                // Update joint visualizations based on joint positions
                // Now that we have a proper kinematic chain, each joint rotation affects all child joints
                for (let i = 0; i < Math.min(this.jointPositions.length, this.jointObjects.length); i++) {
                    const jointObject = this.jointObjects[i];
                    const angle = this.jointPositions[i];
                    
                    if (!jointObject) continue;
                    
                    // Reset rotation before applying new rotation
                    jointObject.rotation.set(0, 0, 0);
                    jointObject.scale.set(1, 1, 1);
                    
                    // Apply rotation based on joint type and URDF-defined axes
                    switch (i) {
                        case 0: // base_link - no rotation (static)
                            break;
                        case 1: // shoulder_pan - rotate around Z axis (yaw)
                            jointObject.rotation.z = angle;
                            break;
                        case 2: // shoulder_lift - rotate around Z axis (pitch relative to shoulder)  
                            jointObject.rotation.z = angle;
                            break;
                        case 3: // elbow_flex - rotate around Z axis (bend elbow)
                            jointObject.rotation.z = angle;
                            break;
                        case 4: // wrist_flex - rotate around Z axis (wrist bend)
                            jointObject.rotation.z = angle;
                            break;
                        case 5: // gripper - rotate around Z axis (gripper open/close)
                            jointObject.rotation.z = angle;
                            break;
                    }
                }
                
                // Also update slider values in UI
                this.updateSliderValues();
            }
            
            updateSliderValues() {
                for (let i = 0; i < this.jointPositions.length; i++) {
                    const slider = document.getElementById(`joint-${i}`);
                    const valueSpan = document.getElementById(`joint-${i}-value`);
                    if (slider && valueSpan) {
                        slider.value = this.jointPositions[i];
                        valueSpan.textContent = this.jointPositions[i].toFixed(2);
                    }
                }
            }
            
            setupControls() {
                const controlsContainer = document.getElementById('joint-controls');
                
                // Create joint sliders
                for (let i = 0; i < this.jointNames.length; i++) {
                    const jointDiv = document.createElement('div');
                    jointDiv.className = 'joint-control';
                    
                    jointDiv.innerHTML = `
                        <label class="block text-sm font-medium mb-2">
                            ${this.jointNames[i].replace('_', ' ')}
                            <span class="text-blue-400 float-right" id="joint-${i}-value">0.00</span>
                        </label>
                        <input type="range" 
                               class="joint-slider" 
                               id="joint-${i}" 
                               min="-3.14" 
                               max="3.14" 
                               step="0.01" 
                               value="0">
                    `;
                    
                    controlsContainer.appendChild(jointDiv);
                    
                    // Add event listener
                    const slider = jointDiv.querySelector(`#joint-${i}`);
                    const valueSpan = jointDiv.querySelector(`#joint-${i}-value`);
                    
                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        valueSpan.textContent = value.toFixed(2);
                        this.setJointPosition(i, value);
                    });
                }
                
                // Demo button event listeners
                document.getElementById('home-position').addEventListener('click', () => {
                    this.goToHomePosition();
                });
                
                document.getElementById('demo-motion').addEventListener('click', () => {
                    this.startDemoMotion();
                });
                
                document.getElementById('random-motion').addEventListener('click', () => {
                    this.randomMotion();
                });
                
                document.getElementById('reset-robot').addEventListener('click', () => {
                    this.resetRobot();
                });
            }
            
            setJointPosition(jointIndex, value) {
                // Update local joint positions
                this.jointPositions[jointIndex] = value;
                
                // Update the robot visualization immediately
                this.updateRobotVisualization();
                
                // Also send to websocket if connected
                this.sendMessage({
                    type: "set_joints",
                    positions: [...this.jointPositions],
                    smooth: true
                });
            }
            
            goToHomePosition() {
                console.log("Going to home position...");
                const homePositions = [0, 0, 0, 0, 0, 0];  // 6 joints
                
                // Update local joint positions
                this.jointPositions = [...homePositions];
                
                // Update the robot visualization
                this.updateRobotVisualization();
                
                // Update sliders to match
                homePositions.forEach((pos, i) => {
                    const slider = document.getElementById(`joint-${i}`);
                    const valueSpan = document.getElementById(`joint-${i}-value`);
                    if (slider) {
                        slider.value = pos;
                        valueSpan.textContent = pos.toFixed(2);
                    }
                });
                
                // Also send to websocket if connected
                this.sendMessage({
                    type: "set_joints",
                    positions: homePositions,
                    smooth: true
                });
            }
            
            startDemoMotion() {
                console.log("Starting demo motion sequence...");
                // Simple demo motion sequence - showcasing robot capabilities
                const motions = [
                    [0, 0, 0, 0, 0, 0],                    // Start at home
                    [0.5, 0.3, -0.5, 0.2, 0.8, 0.5],     // Reach forward and up
                    [-0.5, -0.3, 0.5, -0.2, -0.8, -0.5], // Swing to other side
                    [0, 0.8, -1.2, 0.5, 0, 1.0],         // Tall reach
                    [0, 0, 0, 0, 0, 0]                    // Return home
                ];
                
                let motionIndex = 0;
                const playNextMotion = () => {
                    if (motionIndex < motions.length) {
                        const positions = motions[motionIndex];
                        console.log(`Demo motion ${motionIndex + 1}/${motions.length}:`, positions);
                        
                        // Update local positions and visualization
                        this.jointPositions = [...positions];
                        this.updateRobotVisualization();
                        
                        // Update sliders
                        positions.forEach((pos, i) => {
                            const slider = document.getElementById(`joint-${i}`);
                            const valueSpan = document.getElementById(`joint-${i}-value`);
                            if (slider) {
                                slider.value = pos;
                                valueSpan.textContent = pos.toFixed(2);
                            }
                        });
                        
                        // Send to websocket if connected
                        this.sendMessage({
                            type: "set_joints",
                            positions: positions,
                            smooth: true
                        });
                        
                        motionIndex++;
                        setTimeout(playNextMotion, 2000);  // 2 second delay between motions
                    } else {
                        console.log("Demo motion sequence complete!");
                    }
                };
                
                playNextMotion();
            }
            
            randomMotion() {
                console.log("Generating random motion...");
                // Generate random positions within reasonable joint limits
                const randomPositions = [];
                for (let i = 0; i < 6; i++) {  // 6 joints
                    const randomAngle = (Math.random() - 0.5) * Math.PI;  // ±90 degrees
                    randomPositions.push(randomAngle);
                }
                
                console.log("Random positions:", randomPositions);
                
                // Update local positions and visualization
                this.jointPositions = [...randomPositions];
                this.updateRobotVisualization();
                
                // Update sliders
                randomPositions.forEach((pos, i) => {
                    const slider = document.getElementById(`joint-${i}`);
                    const valueSpan = document.getElementById(`joint-${i}-value`);
                    if (slider) {
                        slider.value = pos;
                        valueSpan.textContent = pos.toFixed(2);
                    }
                });
                
                // Send to websocket if connected
                this.sendMessage({
                    type: "set_joints",
                    positions: randomPositions,
                    smooth: true
                });
            }
            
            resetRobot() {
                console.log("Resetting robot to default state...");
                // Reset robot means: stop any ongoing motions, clear errors, and go to home position
                
                // Stop any ongoing demo motion by clearing any timeouts
                // (In a real implementation, you'd track and clear specific timeouts)
                
                // Reset to home position
                this.goToHomePosition();
                
                // Reset camera to default view (not too close, not too far)
                this.camera.position.set(1.2, 1.2, 1.2);
                this.camera.lookAt(0, 0, 0.2);
                
                console.log("Robot reset complete - returned to home position and default camera view");
            }
            
            startPingLoop() {
                setInterval(() => {
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.lastPingTime = performance.now();
                        this.sendMessage({ type: "ping" });
                    }
                }, 5000);
            }
            
            updateConnectionStatus(connected) {
                const statusDot = document.getElementById('connection-status');
                const statusText = document.getElementById('connection-text');
                const wsStatus = document.getElementById('ws-status');
                
                if (connected) {
                    statusDot.className = 'status-dot status-connected';
                    statusText.textContent = 'Connected';
                    wsStatus.textContent = 'Connected';
                } else {
                    statusDot.className = 'status-dot status-disconnected';
                    statusText.textContent = 'Disconnected';
                    wsStatus.textContent = 'Disconnected';
                }
            }
            
            startAnimation() {
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    
                    // Update FPS
                    this.frameCount++;
                    const currentTime = performance.now();
                    if (currentTime - this.lastTime >= 1000) {
                        this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                        document.getElementById('fps-display').textContent = this.fps;
                        this.frameCount = 0;
                        this.lastTime = currentTime;
                    }
                    
                    // Render scene
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
            
            onWindowResize() {
                const container = document.getElementById('canvas-container');
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }
        
        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SO101Simulation();
        });
    </script>
</body>
</html>
